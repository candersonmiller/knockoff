# 4. `Chunk` Types #

Chunks are used to capture the major blocks in the early stage, and then once we've
grabbed the spanning elements of each block, to construct the final `Block` model.

### `Chunk`

    // The Chunk definition
    trait Chunk {
      def content : String
      def isLinkDefinition = false

      /** Create the Block and append to the list. */
      def appendNewBlock( list : ListBuffer[Block],
                          remaining : List[ (Chunk, Seq[Span], Position) ],
                          spans : Seq[Span], position : Position,
                          discounter : Discounter )
    }
    
### `TextChunk`

Here is where I can apply hard breaks in the middle of paragraphs. If we've
recognized a `Text` span that contains two spaces and a newline, we split the span
sequence at this point into two lists, and then append two blocks. One of them will
be an `HTMLSpan(<br/>)`.

    // The TextChunk
    case class TextChunk( val content : String ) extends Chunk {

      def appendNewBlock( list : ListBuffer[Block],
                          remaining : List[ (Chunk, Seq[Span], Position) ],
                          spans : Seq[Span], position : Position,
                          discounter : Discounter ) {

        val split = splitAtHardBreak( spans, new ListBuffer )
        list += Paragraph( split, position )
      }

      def splitAtHardBreak( spans : Seq[Span], cur : Buffer[Span] )
                          : Seq[Span] = {
        if ( spans.isEmpty ) return cur
        spans.first match {
          case text : Text =>
            // Skip past whitespace in the case we have some HTML.
            var start = 0
            if ( ! cur.isEmpty && cur.last.isInstanceOf[HTMLSpan] )
              while ( start < text.content.length &&
                      Character.isWhitespace( text.content(start) ) )
                start = start + 1
            text.content.indexOf("  \n", start) match {
              case -1 => {}
              case idx =>
                val end = idx + "  \n".length
                val (c1, c2) = ( text.content.substring( 0, idx ),
                                 text.content.substring( end ) )
                cur += Text(c1)
                cur += HTMLSpan("<br/>\n")
                return splitAtHardBreak( List(Text(c2)) ++ spans.drop(1), cur )
            }
          case _ => {}
        }
        return splitAtHardBreak( spans.drop(1), cur + spans.first )
      }
    }

### `HorizontalRuleChunk`

    // The HorizontalRuleChunk
    case object HorizontalRuleChunk extends Chunk {
      val content = "* * *\n"
      
      def appendNewBlock( list : ListBuffer[Block],
                          remaining : List[ (Chunk, Seq[Span], Position) ],
                          spans : Seq[Span], position : Position,
                          discounter : Discounter ) {
        list += HorizontalRule( position )
      }
    }

### `EmptySpace`

Empty space only matters in cases where the lines are indented, which is a way of
dealing with editors that like to do things like strip out whitespace at the end of
a line.

This does not cover forced line brakes.

    // The EmptySpace chunk
    case class EmptySpace( val content : String ) extends Chunk {

      def appendNewBlock( list : ListBuffer[Block],
                          remaining : List[ (Chunk, Seq[Span], Position) ],
                          spans : Seq[Span], position : Position,
                          discounter : Discounter ) {
        if ( remaining.isEmpty ) return
        if ( list.isEmpty ) return
        list.last match {
          case lastCB : CodeBlock =>
            remaining.head._1 match {
              case ice : IndentedChunk =>
                list.update( list.length - 1,
                             CodeBlock( Text( lastCB.text.content + "\n" ),
                                        lastCB.position ) )
              case _ => {}
            }
          case _ => {}
        }
      }
    }

## `BulletLineChunk` ##

    // The BulletLineChunk
    case class BulletLineChunk( val content : String ) extends Chunk {

      def appendNewBlock( list : ListBuffer[Block],
                          remaining : List[ (Chunk, Seq[Span], Position) ],
                          spans : Seq[Span], position : Position,
                          discounter : Discounter ) {
        val li = UnorderedItem( List(Paragraph(spans, position)), position )
        if ( list.isEmpty ) {
          list += UnorderedList( List(li) )
        } else {
          list.last match {
            case ul : UnorderedList =>
              list.update( list.length - 1, UnorderedList( ul.items ++ List(li) ) )
            case _ => list += UnorderedList( List(li) )
          }
        }
      }
    }

## `NumberedLineChunk` ##

    // The NumberedLineChunk
    case class NumberedLineChunk( val content : String ) extends Chunk {

      def appendNewBlock( list : ListBuffer[Block],
                          remaining : List[ (Chunk, Seq[Span], Position) ],
                          spans : Seq[Span], position : Position,
                          discounter : Discounter ) {
        val li = OrderedItem( List(Paragraph(spans, position)), position )
        if ( list.isEmpty ) {
          list += OrderedList( List(li) )
        } else {
          list.last match {
            case ol : OrderedList =>
              list.update( list.length - 1, OrderedList( ol.items ++ List(li) ) )
            case _ => list += OrderedList( List(li) )
          }
        }
      }
    }

## `HeaderChunk` ##

    // The HeaderChunk
    case class HeaderChunk( val level : Int, val content : String ) extends Chunk {

      def appendNewBlock( list : ListBuffer[Block],
                          remaining : List[ (Chunk, Seq[Span], Position) ],
                          spans : Seq[Span], position : Position,
                          discounter : Discounter ) {
        list += Header( level, spans, position )
      }
    }

## `IndentedChunk` ##

This represents a group of lines that have at least 4 spaces or 1 tab preceding the
line.

If the block before is a list, we append this to the end of that list. Otherwise,
append it as a new code block. Two code blocks will get combined here (because it's
common to have an empty line not be indented in many editors). Appending to the end
of a list means that we strip out the first indent and reparse things.

    // The IndentedChunk
    case class IndentedChunk( val content : String ) extends Chunk {

      def appendNewBlock( list : ListBuffer[Block],
                          remaining : List[ (Chunk, Seq[Span], Position) ],
                          spans : Seq[Span], position : Position,
                          discounter : Discounter ) {
        if ( list.isEmpty ) {
          spans.first match {
            case text : Text => list += CodeBlock( text, position )
          }
        } else {
          list.last match {
            case OrderedList( items ) =>
              val blocks = discounter.knockoff( content )
              val li = OrderedItem( items.last.children ++ blocks, items.last.position )
              list.update( list.length - 1, OrderedList( items.take( items.length - 1) ++ List(li) ) )

            case UnorderedList( items ) =>
              val blocks = discounter.knockoff( content )
              val li =
                UnorderedItem( items.last.children ++ blocks, items.last.position )
              list.update( list.length - 1, UnorderedList( items.take( items.length - 1) ++ List(li) ) )

            case CodeBlock( text, position ) =>
              spans.first match {
                case next : Text =>
                  list.update( list.length - 1,
                               CodeBlock(Text(text.content + next.content), position) )
              }
            
            case _ =>
              spans.first match {
                case text : Text => list += CodeBlock( text, position )
              }
          }
        }
      }
    }

## `BlockquotedChunk` ##

Represents a single level of blockquoted material. That means that it could also
contain content, which is then reparsed, recursively.

    // The BlockquotedChunk
    case class BlockquotedChunk( content : String ) extends Chunk {

      /** @param content The material, not parsed, but also not containing this
                         level's '>' characters. */
      def appendNewBlock( list : ListBuffer[Block],
                          remaining : List[ (Chunk, Seq[Span], Position) ],
                          spans : Seq[Span], position : Position,
                          discounter : Discounter ) {
        val blocks = discounter.knockoff( content )
        list += Blockquote( blocks, position )
      }
    }

## `LinkDefinitionChunk` ##

    // The LinkDefinitionChunk
    case class LinkDefinitionChunk( val id : String, val url : String,
                                    val title : Option[ String ] )
    extends Chunk {

      override def isLinkDefinition = true
      
      def content : String =
        "[" + id + "]: " + url + title.map( " \"" + _ + "\"" ).getOrElse("")
      
      def appendNewBlock( list : ListBuffer[Block],
                          remaining : List[ (Chunk, Seq[Span], Position) ],
                          spans : Seq[Span], position : Position,
                          discounter : Discounter ) {
        list += LinkDefinition( id, url, title, position )
      }
    }



## Source Definition ##

    // In com/tristanhunt/knockoff/ChunkTypes.scala
    package com.tristanhunt.knockoff
    
    import scala.collection.mutable.{ Buffer, ListBuffer }
    import scala.util.parsing.input.{ Position }
    
    // See the Chunk definition
    
    // See the BlockquotedChunk

    // See the EmptySpace chunk
    
    // See the HeaderChunk
    
    // See the HorizontalRuleChunk

    // See the IndentedChunk
    
    // See the LinkDefinitionChunk

    // See the NumberedLineChunk
    
    // See the TextChunk
    
    // See the BulletLineChunk
    