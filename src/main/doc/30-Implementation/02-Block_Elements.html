<!DOCTYPE html>
<html>
        <head>
          <title>Block Elements</title>
          <link rel="stylesheet" href="../screen.css" type="text/css" media="screen, projection"></link><link rel="stylesheet" href="../print.css" type="text/css" media="print"></link><!--[if lt IE 8]><link rel="stylesheet" href="../ie.css" type="text/css" media="screen, projection"><![endif]-->
          <link href="../prettify.css" rel="stylesheet" type="text/css"></link><script type="text/javascript" src="../prettify.js"></script>
          <style> 
          /* Overriding a few defaults from blueprint. */
          body {font-size:100%;color:#222;background:#f2e5ca;font-family: Georgia, Times, serif;}
          h1, h2, h3, h4, h5, h6 {font-weight:normal;color:#111;font-family: Georgia, Times, serif;text-transform:uppercase;}
          a:focus, a:hover {color: #222;}
          a {color:#7f2f18;text-decoration:none;}
          code { text-transform: none; }
          
          /* Style the code blocks */
          pre {
            background: #333;
            color: #f2e5ca;
            border: solid #444 1px;
            border-left-width: 1em;
          }
          .str { color:rgb( 237, 239, 125 ); font-style:italic }
          .kwd { color:rgb( 152, 129, 85 ); }
          .com { color:#999 }
          .typ { color:rgb( 255, 101, 33 ); }
          .lit { color:rgb( 112, 83, 147 ); }
          .pun { color:#aaa; font-weight:bold  }
          .pln { color:#f2e5ca }
          .tag { color:rgb( 137, 150, 168 ); font-weight:bold  }
          .atn { color:#939; font-weight:bold  }
          .atv { color:#181 }
          .dec { color:#606 }
          
          /* Custom styling */
          .header { background: #7f2f18; color: #f2e5ca; text-transform:uppercase; margin-bottom: 2em; vertical-align: center; }
          .header a { color: #f2e5ca }
          .header a:focus, a:hover {color: #222; background: #7f2f18 }
          .header ul { list-style-type: none; margin: 0; padding: 0; }
          .header ul li { display: inline; padding-right: 2em; }
           </style>
        </head>
        <body onload="prettyPrint()" class="container"><div class="section">
      <div class="header span-22 prepend-1 append-1 last">
      <ul style="list-style-type: none">
            <li><a href="../../..">tristanhunt.com</a></li>
            <li><a href="http://github.com/tristanjuricek/knockoff">GitHub</a></li>
            <li><a href="../../literable">Literable</a></li>
        </ul>
    </div>
      <div class="nav small span-7 prepend-1"><ul><li>
            <a href="../01-Introduction.html">
              Introduction to Knockoff
            </a>
          </li><li>
            <span class="group">Usage</span>
            <ul>
              <li>
            <a href="../10-Usage/01-Getting_Started.html">
              Getting Started
            </a>
          </li><li>
            <a href="../10-Usage/02-Recipes.html">
              Recipes
            </a>
          </li>
            </ul>
          </li><li>
            <span class="group">Implementation</span>
            <ul>
              <li>
            <a href="../30-Implementation/01-Discounter.html">
              Discounter - The One Trait
            </a>
          </li><li>
            <a href="../30-Implementation/02-Block_Elements.html">
              Block Elements
            </a>
          </li><li>
            <a href="../30-Implementation/03-Span_Elements.html">
              Spanning Elements
            </a>
          </li><li>
            <a href="../30-Implementation/04-ElementFactory.html">
              ElementFactory
            </a>
          </li><li>
            <span class="group">Parsing</span>
            <ul>
              <li>
            <a href="../30-Implementation/10-Parsing/01-Parsing.html">
              Parsing Overview
            </a>
          </li><li>
            <a href="../30-Implementation/10-Parsing/10-ChunkStreamFactory.html">
              ChunkStreamFactory
            </a>
          </li><li>
            <a href="../30-Implementation/10-Parsing/11-ChunkParsers.html">
              ChunkParsers
            </a>
          </li><li>
            <a href="../30-Implementation/10-Parsing/12-Chunk_Types.html">
              Chunk Types
            </a>
          </li><li>
            <a href="../30-Implementation/10-Parsing/20-Span_Conversion.html">
              Span Conversion
            </a>
          </li>
            </ul>
          </li><li>
            <a href="../30-Implementation/50-Official_Markdown_Tests.html">
              The Official Tests
            </a>
          </li><li>
            <span class="group">Utilities</span>
            <ul>
              <li>
            <a href="../30-Implementation/80-Utilities/01-String_Extras.html">
              StringExtras
            </a>
          </li><li>
            <a href="../30-Implementation/80-Utilities/02-ColoredLogger.html">
              ColoredLogger
            </a>
          </li>
            </ul>
          </li>
            </ul>
          </li></ul></div>
      <div class="article span-15 append-1 last"><h1>Block Elements</h1><h2><code>Block</code></h2><p><code>Block</code>s are kind of the grouping elements of a system. Other things are laid out
inside of <code>Blocks</code>: namely <code>Span</code>s, but also, other blocks. In the markdown, blocks
are usually seen as separated by whitespace lines.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/Block.scala
// See the Block package and imports

trait Block extends BlockSeq {
    
  /**
    The actual content of each block.
   */
  val span     : SpanSeq

  /**
    A markdown representation of this block - it may not equal the original
    source.
   */
  def markdown : String

  /**
    An HTML rendering of the Block element.
   */
  def xml      : Node
  
  /**
    The original source position used to make up this block.
   */
  val position : Position
}
</code></pre><p>In many cases, the Block can not contain other blocks.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/SimpleBlock.scala
package com.tristanhunt.knockoff

trait SimpleBlock extends Block {
    override def theSeq : Seq[ Block ] = List( this )
}
</code></pre><p>In some other cases, the block is a pretty complex thing:
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/ComplexBlock.scala
package com.tristanhunt.knockoff

trait ComplexBlock extends Block {
    val children : Seq[ Block ]
    val span = new SpanSeq{ def theSeq = children.flatMap( _.span ) }
    def theSeq = children
    def childrenMarkdown = children.map( _.markdown ).mkString(&quot;\n&quot;) + &quot;\n&quot;
    def childrenXML = children.map( _.xml )
}
</code></pre><p>There are moments when we need to capture a series of blocks as a <code>ComplexBlock</code>
without any other real information.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/GroupBlock.scala
package com.tristanhunt.knockoff

import scala.xml.{ Node, Group }
import scala.util.parsing.input.{ NoPosition, Position }

class   GroupBlock( val children : Seq[ Block ] )
extends ComplexBlock {
 
  val position : Position = children.firstOption match {
    case None =&gt; NoPosition
    case Some( child ) =&gt; child.position
  }
     
  def markdown = childrenMarkdown
  
  def xml : Node = Group( children.map( _.xml ) )

  override def toString = &quot;GroupBlock(&quot; + markdown + &quot;)&quot;
}
</code></pre><h2><code>BlockSeq</code></h2><p>The <code>BlockSeq</code> adds searching methods over <code>Block</code> elements. It is also the
main return type of the <code>KnockOff.parse</code> method.
</p><p>One of the shorthand filter expressions allows for you to indicate the &quot;BlockType&quot;.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/BlockType.scala
package com.tristanhunt.knockoff

/**
 * Used to indicate the type of blocks you are interested in when filtering via
 * the BlockSeq.? method.
 */
trait BlockType[T &lt;: Block] { def wrappedClass : Class[ T ] }

case object Paragraphs
extends BlockType[ Paragraph ] { def wrappedClass = classOf[ Paragraph ] }

case object Headers
extends BlockType[ Header ] { def wrappedClass = classOf[ Header ] }
</code></pre><p>This is used only as a short hand for query expressions.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/BlockSeq.scala
// See the BlockSeq package and imports

trait BlockSeq extends Seq[ Block ] {
  
  def theSeq : Seq[ Block ]
  
  override def length : Int = theSeq.length
  
  override def elements = theSeq.elements
  
  override def apply( ii : Int ) = theSeq(ii)

  def toXML : Node = Group( theSeq.map( _.xml ) )

  /**
   * Returns a BlockSeq that contains only that particular block type.
   */
  def ? [ T &lt;: Block ] ( blockType : BlockType[T] ) : BlockSeq = {
    BlockSeq.fromSeq( filter( blockType.wrappedClass.isInstance( _ ) ) )
  }
  
  
  /** Shorthand for the filter method. */
  def ? ( query : Block =&gt; Boolean ) : BlockSeq =
    BlockSeq.fromSeq( filter( query ) )
}

object BlockSeq {
    
  def fromSeq( seq : Seq[ Block ] ) = new BlockSeq {
    override def theSeq = seq
  }
}
</code></pre><h2><code>Paragraph</code></h2><p>The text block element that is represented inside a <code>&lt;p&gt;</code> tag. Does not
contain any other useful metadata.
</p><p>Otherwise the paragraph is a simple <code>Block</code> type (does not contain other
<code>Block</code>s).
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/Paragraph.scala
// See the Paragraph package and imports

class Paragraph(
  val span      : SpanSeq,
  val position  : Position
)
extends SimpleBlock {

  def markdown = span.toMarkdown

  /**
    If this paragraph only contains HTMLSpan elements, then just pass that
    information through without a paragraph marker.
  */
  def xml =
    if ( isHTML ) span.toXML else &lt;p&gt;{ span.toXML }&lt;/p&gt;
  
  def isHTML : Boolean = ! span.exists( s =&gt; s match {
    case html : HTMLSpan =&gt; false
    case t:Text =&gt; ! t.content.trim.isEmpty
    case _ =&gt; true
  } )
  
  // See the Paragraph toString, equals, hashCode implementations
}
</code></pre><h2><code>Header</code></h2><p>Represents an <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, etc., element in the markdown document.
</p><p>The header element is a simple <code>Block</code> type, but can contain any kind of
<code>SpanSeq</code>.
</p><p>The <code>markdown</code> representation of the Header should always be the ATX-style
headers - <code># Header #</code>.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/Header.scala
// See the Header package and imports

class Header(
  val level     : Int,
  val span      : SpanSeq,
  val position  : Position
)
extends SimpleBlock {

  def markdown = {
    val sb = new StringBuilder
    ( 0 until level ).foreach( _ =&gt; sb.append(&quot;#&quot;) )
    sb.append(&quot; &quot;).append( span.toMarkdown ).append(&quot; &quot;)
    ( 0 until level ).foreach( _ =&gt; sb.append(&quot;#&quot;) )
    sb.toString
  }
  
  def xml = level match {
    case 1 =&gt; &lt;h1&gt;{ span.toXML }&lt;/h1&gt;
    case 2 =&gt; &lt;h2&gt;{ span.toXML }&lt;/h2&gt;
    case 3 =&gt; &lt;h3&gt;{ span.toXML }&lt;/h3&gt;
    case 4 =&gt; &lt;h4&gt;{ span.toXML }&lt;/h4&gt;
    case 5 =&gt; &lt;h5&gt;{ span.toXML }&lt;/h5&gt;
    case 6 =&gt; &lt;h6&gt;{ span.toXML }&lt;/h6&gt;
    case _ =&gt; &lt;div class={ &quot;header&quot; + level }&gt;{ span.toXML }&lt;/div&gt;
  }

  // See the Header toString, equals, hashCode implementations
}
</code></pre><h2><code>LinkDefinition</code></h2><p>When a link is created with the definition like <code>[something][id]</code>, that <code>id</code> can
be defined later on a string like <code>[id]: url &quot;optional title&quot;</code>.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/LinkDefinition.scala
// See the LinkDefinition package and imports

class LinkDefinition(
  val id        : String,
  val url       : String,
  val title     : Option[ String ],
  val position  : Position
)
extends SimpleBlock {

  val span = Span.empty

  def xml : Node = Group( Nil )
  
  def markdown = {
    val sb = new StringBuilder
    sb.append(&quot;[&quot;).append( id ).append(&quot;]: &quot;).append( url ).append(
      title match {
        case None =&gt; &quot;&quot;
        // Remember that &quot;This &quot;Title&quot; is Valid&quot; as a single title.
        case Some( titleValue ) =&gt; &quot;\&quot;&quot; + titleValue + &quot;\&quot;&quot;
      }
    )
    sb.toString
  }
  
  // See the LinkDefinition toString, equals, hashCode implementations
}
</code></pre><h2><code>Blockquote</code></h2><p>A block quote is really another markdown document, quoted.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/Blockquote.scala
// See the Blockquote package and imports

class Blockquote(
  val children : BlockSeq,
  val position : Position
)
extends ComplexBlock {
            
  def markdown : String = {
    Source.fromString( childrenMarkdown )
      .getLines.map( l =&gt; &quot;&gt; &quot; + l ).mkString(&quot;&quot;)
  }
  
  def xml : Elem = &lt;blockquote&gt;{ childrenXML }&lt;/blockquote&gt;
  
  // See the Blockquote toString, equals, hashCode implementations
}
</code></pre><h2><code>CodeBlock</code></h2><p>The code block is a chunk of preformatted text to this system. Note that this means
we completely ignore all formatting, and do escaping. This means that sequences like
</p><pre><code class="prettyprint">&lt;later&gt;
</code></pre><p>become this in the output:
</p><pre><code class="prettyprint">&lt;pre&gt;&lt;code&gt;&amp;le;later&amp;gt;&lt;/pre&gt;&lt;/code&gt;
</code></pre><p>This means that in order to inject actual HTML inside the final code, you'll have to
write up an HTML code element. This could be seen as a later transformation, say,
if you want to inject a series of line numbers via <code>&lt;span&gt;</code> elements.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/CodeBlock.scala
// See the CodeBlock package and imports

class   CodeBlock( val text : Text, val position : Position )
extends SimpleBlock {

  def this( preformatted : String, position : Position ) =
    this( new Text( preformatted ), position )

  val span = text

  val preformatted = text.markdown
  
  lazy val preformattedLines =
    Source.fromString( preformatted ).getLines
  
  def markdown =
    preformattedLines.map{ line =&gt;  &quot;    &quot; + line }.mkString(&quot;&quot;)
      
  def xml : Node = &lt;pre&gt;&lt;code&gt;{ preformatted }&lt;/code&gt;&lt;/pre&gt;
  
  // See the CodeBlock toString, equals, hashCode implementations
}
</code></pre><h2><code>HorizontalRule</code></h2><p>Represents a <code>&lt;hr/&gt;</code> injected into content. Note that this does not happen to do
anything but replace a line of asterixes, underscores, or hyphens.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/HorizontalRule.scala
// See the HorizontalRule package and imports

class HorizontalRule( val position : Position ) extends SimpleBlock {
  
  def markdown = &quot;* * *&quot;
  
  val span = new Text( markdown )
  
  def xml = &lt;hr/&gt;

  // See the HorizontalRule toString, equals, hashCode implementations
}
</code></pre><h2>Lists - Unordered, Ordered, Simple, and Complex</h2><p>Lists in markdown can be simple or complex. It becomes complex when any one of the
list items have more than one <code>Block</code>. They are either tagged as ordered or
unordered, though the <code>ElementFactory</code> has helper methods to make this decision.
</p><p>How this might look in code:
</p><pre><code class="prettyprint">val olist = olist(
  oi( para(&quot;some text&quot;) ),
  oi( para(&quot;uno&quot;), para(&quot;dos&quot;) )
)

val ulist = ulist(
  ui(&quot;list item 1&quot;),
  ui(&quot;list item 2&quot;)
)
</code></pre><p>Note the difference between the list items <code>oi</code> of the <code>olist</code> and the <code>ui</code> of the
<code>ulist</code>. This makes discovery of the list much simpler during the parsing process,
and prevents you from mistakenly globbing inconsistent lists together.
</p><p>These codes would be represented as:
</p><pre><code class="prettyprint">&lt;ol&gt;
  &lt;li&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;uno&lt;/p&gt;&lt;p&gt;dos&lt;/p&gt;&lt;li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>Only in the simple list case do we let the <code>&lt;li&gt;</code> operate as a simple implicit block
container.
</p><p>In implementation terms, we don't have a single list.
</p><h4><code>ListItem</code></h4><pre><code class="prettyprint">// In com/tristanhunt/knockoff/ListItem.scala
package com.tristanhunt.knockoff

import scala.util.parsing.input.Position
import scala.xml.Node

abstract class ListItem(
  val items    : Seq[ Block ],
  val position : Position
)
extends ComplexBlock {
  
  val children = new GroupBlock( items )

  def itemPrefix : String
  
  def markdown : String = {
    if ( children.isEmpty ) return &quot;&quot;

    return (
      ( itemPrefix + children.first.markdown + &quot;  \n&quot; ) +
      children.drop(1).map( &quot;    &quot; + _.markdown + &quot;  \n&quot; ).mkString( &quot;&quot; )
    )
  }
  
  def xml( complex : Boolean ) : Node = &lt;li&gt;{
    if ( isComplex )
      childrenXML 
    else
      children.first.span.toXML
  }&lt;/li&gt;
  
  def xml : Node = xml( isComplex )
  
  def isComplex = items.length &gt; 1
  
  def + ( block : Block ) : ListItem
  
  // See the ListItem toString, equals, hashCode implementation
}
  
</code></pre><h3><code>OrderedItem</code></h3><pre><code class="prettyprint">// In com/tristanhunt/knockoff/OrderedItem.scala
package com.tristanhunt.knockoff

import scala.util.parsing.input.Position

class OrderedItem( items : Seq[ Block ], position : Position )
extends ListItem( items, position ) {

  def this( block : Block, position : Position ) =
    this( Seq( block ), position )
  
  def itemPrefix = &quot;1. &quot;
  
  def + ( b : Block ) : ListItem =
    new OrderedItem( children ++ Seq(b), children.first.position )
}
</code></pre><h3><code>UnorderedItem</code></h3><pre><code class="prettyprint">// In com/tristanhunt/knockoff/UnorderedItem.scala
package com.tristanhunt.knockoff

import scala.util.parsing.input.Position
    
class UnorderedItem( items : Seq[ Block ], position : Position )
extends ListItem( items, position ) {
  
  def this( block : Block, position : Position ) =
    this( Seq( block ), position )
  
  def itemPrefix = &quot;* &quot;
  
  def + ( b : Block ) : ListItem =
    new UnorderedItem( children ++ Seq(b), children.first.position )
}
</code></pre><h4><code>MarkdownList</code></h4><p>Lists just contain items, and are either ordered or unordered.
</p><p>The position of a list is a little spurious: the start of the list should be
the position of the first item, however, it's elements may not contain the
entire content; whitespace will be missing in complex cases.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/MarkdownList.scala
package com.tristanhunt.knockoff

import scala.io.Source
import scala.util.parsing.input.{ NoPosition, Position }

/**
 * @param ordered Alters the output, mostly.
 */
abstract class MarkdownList(
  val items : Seq[ ListItem ]
) extends ComplexBlock {
  
  val children = items
  
  val position = children.firstOption match {
    case None =&gt; NoPosition
    case Some( child ) =&gt; child.position
  }
  
  def markdown = childrenMarkdown
  
  /**
    Create a new list with the block appended to the last item.
  */
  def + ( block : Block ) : MarkdownList 
  
  // See the MarkdownList toString, equals, hashCode implementations
}

class OrderedList( items : Seq[ ListItem ] )
extends MarkdownList( items ) {
 
  def xml = &lt;ol&gt;{ childrenXML }&lt;/ol&gt;
  
  def + ( item : OrderedItem ) : OrderedList =
    new OrderedList( children ++ Seq(item) )

  def + ( block : Block ) : MarkdownList = new OrderedList(
    children.take( children.length - 1 ) ++ Seq(children.last + block)
  )
}

class UnorderedList( items : Seq[ ListItem ] )
extends MarkdownList( items ) {
 
  def xml = &lt;ul&gt;{ childrenXML }&lt;/ul&gt;
  
  def + ( item : UnorderedItem ) : UnorderedList =
    new UnorderedList( children ++ Seq(item) )

  def + ( block : Block ) : MarkdownList = new UnorderedList(
    children.take( children.length - 1 ) ++ Seq(children.last + block)
  )
}

</code></pre><h2>Block Specification</h2><pre><code class="prettyprint">// In test com/tristanhunt/knockoff/BlockSuite.scala
package com.tristanhunt.knockoff

import scala.util.parsing.input.NoPosition
import org.scalatest._
import matchers._

class BlockSuite extends Spec with ShouldMatchers with HasElementFactory {

  val factory = elementFactory
  import factory._

  describe(&quot;BlockSeq&quot;) {

    it( &quot;should filter Paragraphs and Headers properly with ?&quot; ) {

      val p1 = para( t(&quot;p1&quot;), NoPosition )
      val h1 = head( 1, t(&quot;h1&quot;), NoPosition )

      val blocks = BlockSeq.fromSeq( List( p1, h1 ) )
      
      ( blocks ? Paragraphs ) should have length (1)
      assert( ( blocks ? Paragraphs ) contains p1 )
      
      ( blocks ? Headers ) should have length (1)
      assert( ( blocks ? Headers ) contains h1 )
    }
  }
  
  describe(&quot;MarkdownList&quot;) {
    
    it(&quot;should implement simple lists&quot;) {
        
    }
    
    it(&quot;should implement complex lists&quot;) {
        
    }
  }
}
</code></pre><h2>References</h2><h4>Block - Package And Imports</h4><pre><code class="prettyprint">// The Block package and imports
package com.tristanhunt.knockoff

import scala.xml.Node
import scala.util.parsing.input.Position
</code></pre><h4>BlockSeq - Package And Imports</h4><pre><code class="prettyprint">// The BlockSeq package and imports
package com.tristanhunt.knockoff

import scala.xml.{ Node, Elem, Group }
</code></pre><h3><code>Paragraph</code></h3><h4><code>Paragraph</code> - Package And Imports</h4><pre><code class="prettyprint">// The Paragraph package and imports
package com.tristanhunt.knockoff

import scala.xml.Elem
import scala.util.parsing.input.Position
</code></pre><h4><code>Paragraph</code> - <code>toString</code>, <code>equals</code>, <code>hashCode</code></h4><pre><code class="prettyprint">// The Paragraph toString, equals, hashCode implementations
override def toString = &quot;Paragraph(&quot; + markdown + &quot;)&quot;

override def equals( rhs : Any ):Boolean = rhs match {
  case oth : Paragraph =&gt; ( oth canEqual this ) &amp;&amp; ( this sameElements oth )
  case _ =&gt; false
}

def canEqual( p : Paragraph ) : Boolean = ( getClass == p.getClass )

def sameElements( p : Paragraph ) : Boolean = {
  ( span == p.span ) &amp;&amp;
  ( position == p.position )
}

override def hashCode : Int = span.hashCode + position.hashCode
</code></pre><h3><code>Header</code></h3><h4><code>Header</code> - Package And Imports</h4><pre><code class="prettyprint">// The Header package and imports
package com.tristanhunt.knockoff

import scala.xml.Elem
import scala.util.parsing.input.Position
</code></pre><h4><code>Header</code> - <code>toString</code>, <code>equals</code>, <code>hashCode</code></h4><pre><code class="prettyprint">// The Header toString, equals, hashCode implementations
override def toString = &quot;Header(&quot; + markdown + &quot;)&quot;

override def equals( rhs : Any ):Boolean = rhs match {
  case oth : Header =&gt; ( oth canEqual this ) &amp;&amp; ( this sameElements oth )
  case _ =&gt; false
}

def canEqual( p : Header ) : Boolean = ( getClass == p.getClass )

def sameElements( p : Header ) : Boolean = {
  ( level == p.level ) &amp;&amp;
  ( span == p.span ) &amp;&amp;
  ( position == p.position )
}

override def hashCode : Int =
  43 + level + span.hashCode + position.hashCode
</code></pre><h3><code>LinkDefinition</code></h3><h4><code>LinkDefinition</code> - Package And Imports</h4><pre><code class="prettyprint">// The LinkDefinition package and imports
package com.tristanhunt.knockoff

import scala.xml.{ Node, Group }
import scala.util.parsing.input.Position
</code></pre><h4><code>LinkDefinition</code> - <code>toString</code>, <code>equals</code>, <code>hashCode</code></h4><pre><code class="prettyprint">// The LinkDefinition toString, equals, hashCode implementations
override def toString = &quot;LinkDefinition(&quot; + markdown + &quot;)&quot;

override def equals( rhs : Any ):Boolean = rhs match {
  case oth : LinkDefinition =&gt; ( oth canEqual this ) &amp;&amp; ( this sameElements oth )
  case _ =&gt; false
}

def canEqual( p : LinkDefinition ) : Boolean = ( getClass == p.getClass )

def sameElements( p : LinkDefinition ) : Boolean = {
  ( id == p.id ) &amp;&amp;
  ( url == p.url ) &amp;&amp;
  ( title == p.title ) &amp;&amp;
  ( position == p.position )
}

override def hashCode : Int =
  43 + id.hashCode + url.hashCode + span.hashCode + position.hashCode
</code></pre><h3><code>Blockquote</code></h3><h4><code>Blockquote</code> - Package And Imports</h4><pre><code class="prettyprint">// The Blockquote package and imports
package com.tristanhunt.knockoff

import scala.io.Source
import scala.xml.Elem
import scala.util.parsing.input.Position
</code></pre><h4><code>Blockquote</code> - <code>toString</code>, <code>equals</code>, <code>hashCode</code></h4><pre><code class="prettyprint">// The Blockquote toString, equals, hashCode implementations
override def toString = &quot;Blockquote(&quot; + markdown + &quot;)&quot;

override def equals( rhs : Any ):Boolean = rhs match {
  case oth : Blockquote =&gt; ( oth canEqual this ) &amp;&amp; ( this sameElements oth )
  case _ =&gt; false
}

def canEqual( b : Blockquote ) : Boolean = ( getClass == b.getClass )

def sameElements( b : Blockquote ) = {
  ( children sameElements b.children ) &amp;&amp;
  ( position == b.position )
}

override def hashCode : Int = {
  43 + (
    ( 3 /: children ){
      (sum, child) =&gt; { sum + 43 + 3 * child.hashCode }
    }
  )
}
</code></pre><h3><code>CodeBlock</code></h3><h4><code>CodeBlock</code> - Package and Imports</h4><pre><code class="prettyprint">// The CodeBlock package and imports
package com.tristanhunt.knockoff

import scala.xml.{ Node, Unparsed }
import scala.io.Source
import scala.util.parsing.input.Position
</code></pre><h4><code>CodeBlock</code> - <code>toString</code>, <code>equals</code>, <code>hashCode</code></h4><pre><code class="prettyprint">// The CodeBlock toString, equals, hashCode implementations
override def toString = &quot;CodeBlock(&quot; + preformatted + &quot;)&quot;

override def hashCode : Int = preformatted.hashCode

override def equals( rhs : Any ) : Boolean = rhs match {
  case t : CodeBlock =&gt; t.canEqual( this ) &amp;&amp; ( this sameElements t )
  case _ =&gt; false
}

def sameElements( cb : CodeBlock ) : Boolean = {
  ( cb.preformatted == preformatted ) &amp;&amp;
  ( cb.position == position )
}

def canEqual( t : CodeBlock ) : Boolean = t.getClass == getClass
</code></pre><h3><code>HorizontalRule</code></h3><h4><code>HorizontalRule</code> - Package and Imports</h4><pre><code class="prettyprint">// The HorizontalRule package and imports
package com.tristanhunt.knockoff

import scala.xml.{ Node, Unparsed }
import scala.io.Source
import scala.util.parsing.input.Position
</code></pre><h4><code>HorizontalRule</code> - <code>toString</code>, <code>equals</code>, <code>hashCode</code></h4><pre><code class="prettyprint">// The HorizontalRule toString, equals, hashCode implementations
override def toString = &quot;HorizontalRule&quot;

override def hashCode : Int = position.hashCode + 47

override def equals( rhs : Any ) : Boolean = rhs match {
  case t : HorizontalRule =&gt; t.canEqual( this ) &amp;&amp; ( t.position == position )
  case _ =&gt; false
}

def canEqual( t : HorizontalRule ) : Boolean = t.getClass == getClass
</code></pre><h3><code>ListItem</code></h3><h4><code>ListItem</code> - <code>toString</code>, <code>equals</code>, <code>hashCode</code></h4><pre><code class="prettyprint">// The ListItem toString, equals, hashCode implementations
override def toString = &quot;ListItem(&quot; + markdown + &quot;)&quot;

override def hashCode : Int =  {
  ( 11 /: children )( (total, child) =&gt; total + 51 + 3 * child.hashCode ) +
  position.hashCode + 47
}

override def equals( rhs : Any ) : Boolean = rhs match {
  case t : ListItem =&gt; t.canEqual( this ) &amp;&amp; ( this sameElements t )
  case _ =&gt; false
}

def sameElements( ci : ListItem ) : Boolean = {
  ( children == ci.children ) &amp;&amp;
  ( position == ci.position )
}

def canEqual( t : ListItem ) : Boolean = t.getClass == getClass
</code></pre><h3><code>MarkdownList</code></h3><h4><code>MarkdownList</code> - Package and Imports</h4><pre><code class="prettyprint">// The MarkdownList package and imports
package com.tristanhunt.knockoff

import scala.xml.{ Node, Unparsed }
import scala.io.Source
</code></pre><h4><code>MarkdownList</code> - <code>toString</code>, <code>equals</code>, <code>hashCode</code></h4><pre><code class="prettyprint">// The MarkdownList toString, equals, hashCode implementations
override def toString = &quot;MarkdownList(&quot; + markdown + &quot;)&quot;

override def hashCode : Int = {
  ( 13 /: children )( (total, child) =&gt; total + 51 + 3 * child.hashCode ) +
  position.hashCode + 47
}

override def equals( rhs : Any ) : Boolean = rhs match {
  case t : MarkdownList =&gt; t.canEqual( this ) &amp;&amp; ( t sameElements this )
  case _ =&gt; false
}

def sameElements( ml : MarkdownList ) : Boolean = {
  ( children sameElements ml.children )
}

def canEqual( t : MarkdownList ) : Boolean = t.getClass == getClass
</code></pre></div>
      <div class="footer span-22 prepend-1 append-1 last">
      
    </div>
    </div></body>
      </html>