<!DOCTYPE html>
<html>
        <head>
          <title>Chunk Types</title>
          <link rel="stylesheet" href="../../screen.css" type="text/css" media="screen, projection"></link><link rel="stylesheet" href="../../print.css" type="text/css" media="print"></link><!--[if lt IE 8]><link rel="stylesheet" href="../../ie.css" type="text/css" media="screen, projection"><![endif]-->
          <link href="../../prettify.css" rel="stylesheet" type="text/css"></link><script type="text/javascript" src="../../prettify.js"></script>
          <style> 
          /* Overriding a few defaults from blueprint. */
          body {font-size:100%;color:#222;background:#f2e5ca;font-family: Georgia, Times, serif;}
          h1, h2, h3, h4, h5, h6 {font-weight:normal;color:#111;font-family: Georgia, Times, serif;text-transform:uppercase;}
          a:focus, a:hover {color: #222;}
          a {color:#7f2f18;text-decoration:none;}
          code { text-transform: none; }
          
          /* Style the code blocks */
          pre {
            background: #333;
            color: #f2e5ca;
            border: solid #444 1px;
            border-left-width: 1em;
          }
          .str { color:rgb( 237, 239, 125 ); font-style:italic }
          .kwd { color:rgb( 152, 129, 85 ); }
          .com { color:#999 }
          .typ { color:rgb( 255, 101, 33 ); }
          .lit { color:rgb( 112, 83, 147 ); }
          .pun { color:#aaa; font-weight:bold  }
          .pln { color:#f2e5ca }
          .tag { color:rgb( 137, 150, 168 ); font-weight:bold  }
          .atn { color:#939; font-weight:bold  }
          .atv { color:#181 }
          .dec { color:#606 }
          
          /* Custom styling */
          .header { background: #7f2f18; color: #f2e5ca; text-transform:uppercase; margin-bottom: 2em; vertical-align: center; }
          .header a { color: #f2e5ca }
          .header a:focus, a:hover {color: #222; background: #7f2f18 }
          .header ul { list-style-type: none; margin: 0; padding: 0; }
          .header ul li { display: inline; padding-right: 2em; }
           </style>
        </head>
        <body onload="prettyPrint()" class="container"><div class="section">
      <div class="header span-22 prepend-1 append-1 last">
      <ul style="list-style-type: none">
            <li><a href="../../../..">tristanhunt.com</a></li>
            <li><a href="http://github.com/tristanjuricek/knockoff">GitHub</a></li>
            <li><a href="../../../literable">Literable</a></li>
        </ul>
    </div>
      <div class="nav small span-7 prepend-1"><ul><li>
            <a href="../../01-Introduction.html">
              Introduction to Knockoff
            </a>
          </li><li>
            <span class="group">Usage</span>
            <ul>
              <li>
            <a href="../../10-Usage/01-Getting_Started.html">
              Getting Started
            </a>
          </li><li>
            <a href="../../10-Usage/02-Recipes.html">
              Recipes
            </a>
          </li><li>
            <a href="../../10-Usage/50-Variations.html">
              Where Knockoff is not like Markdown
            </a>
          </li>
            </ul>
          </li><li>
            <span class="group">Implementation</span>
            <ul>
              <li>
            <a href="../../30-Implementation/01-Discounter_DefaultDiscounter_Wholesaler.html">
              Discounter and the Wholesaler
            </a>
          </li><li>
            <a href="../../30-Implementation/02-Block_Elements.html">
              Block Elements
            </a>
          </li><li>
            <a href="../../30-Implementation/03-Span_Elements.html">
              Spanning Elements
            </a>
          </li><li>
            <a href="../../30-Implementation/04-ElementFactory.html">
              ElementFactory
            </a>
          </li><li>
            <span class="group">Parsing</span>
            <ul>
              <li>
            <a href="../../30-Implementation/10-Parsing/01-Parsing.html">
              Parsing Overview
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/10-ChunkStreamFactory.html">
              ChunkStreamFactory
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/11-ChunkParsers.html">
              ChunkParsers
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/12-Chunk_Types.html">
              Chunk Types
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/20-Span_Conversion.html">
              Span Conversion
            </a>
          </li>
            </ul>
          </li><li>
            <span class="group">Extras</span>
            <ul>
              <li>
            <a href="../../30-Implementation/30-Extras/02-MetaDataConverter.html">
              MetaData and MetaDataConverter
            </a>
          </li>
            </ul>
          </li><li>
            <a href="../../30-Implementation/50-Official_Markdown_Tests.html">
              The Official Tests
            </a>
          </li><li>
            <span class="group">Utilities</span>
            <ul>
              <li>
            <a href="../../30-Implementation/80-Utilities/01-String_Extras.html">
              StringExtras
            </a>
          </li><li>
            <a href="../../30-Implementation/80-Utilities/02-ColoredLogger.html">
              ColoredLogger
            </a>
          </li>
            </ul>
          </li>
            </ul>
          </li></ul></div>
      <div class="article span-15 append-1 last"><h1><code>Chunk</code> Types</h1><p>This is more of a reference to the typing of chunks.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/Chunk.scala
package com.tristanhunt.knockoff

import scala.collection.mutable.ListBuffer
import scala.util.parsing.input.Position

trait Chunk {
  def content : String
  
  def isLinkDefinition = false

  /** Create the Block and append to the list. */
  def appendNewBlock( list : ListBuffer[ Block ],
                      remaining : List[ (Chunk, SpanSeq, Position) ],
                      spans : SpanSeq, position : Position )
                    ( elementFactory : ElementFactory, discounter : Discounter )
}

</code></pre><h2><code>TextChunk</code></h2><pre><code class="prettyprint">// In com/tristanhunt/knockoff/TextChunk.scala
package com.tristanhunt.knockoff

import scala.collection.mutable.ListBuffer
import scala.util.parsing.input.Position

/** Mostly, a Chunk that is not empty. */
case class TextChunk( val content : String ) extends Chunk {

  def appendNewBlock( list : ListBuffer[ Block ],
                      remaining : List[ (Chunk, SpanSeq, Position) ],
                      spans : SpanSeq,
                      position : Position )
                    ( elementFactory : ElementFactory, discounter : Discounter )
  : Unit = {
    list += elementFactory.para( elementFactory.toSpan( spans ), position )
  }
}
</code></pre><h2><code>HorizontalRuleChunk</code></h2><pre><code class="prettyprint">// In com/tristanhunt/knockoff/HorizontalRuleChunk.scala
package com.tristanhunt.knockoff

import scala.collection.mutable.ListBuffer
import scala.util.parsing.input.Position

case object HorizontalRuleChunk extends Chunk {
  val content = &quot;* * *\n&quot;
  
  def appendNewBlock( list : ListBuffer[ Block ],
                      remaining : List[ (Chunk, SpanSeq, Position) ],
                      spans : SpanSeq,
                      position : Position )
                    ( elementFactory : ElementFactory, discounter : Discounter )
  : Unit = {
    list += elementFactory.hr( position )
  }
}
</code></pre><h2><code>EmptySpace</code></h2><pre><code class="prettyprint">// In com/tristanhunt/knockoff/EmptySpace.scala
package com.tristanhunt.knockoff

import scala.collection.mutable.ListBuffer
import scala.util.parsing.input.Position

/** Note that this does not cover forced line breaks. */
case class EmptySpace( val content : String ) extends Chunk {

  /**
    Empty space only matters in cases where the lines are indented, which is a
    way of dealing with editors that like to do things like strip out whitespace
    at the end of a line.
  */
  def appendNewBlock( list : ListBuffer[ Block ],
                      remaining : List[ (Chunk, SpanSeq, Position) ],
                      spans : SpanSeq,
                      position : Position )
                    ( elementFactory : ElementFactory, discounter : Discounter )
  : Unit = {
    if ( remaining.isEmpty ) return
    if ( list.isEmpty ) return
    list.last match {
      case lastCB : CodeBlock =&gt; remaining.first._1 match {
        case ice : IndentedChunk =&gt;
          list.update( list.length - 1,
                       elementFactory.codeBlock(
                         elementFactory.text( lastCB.text.content + &quot;\n&quot; ),
                         lastCB.position ) )
        case _ =&gt; {}
      }
      case _ =&gt; {}
    }
  }
}
</code></pre><h2><code>BulletLineChunk</code></h2><pre><code class="prettyprint">// In com/tristanhunt/knockoff/BulletLineChunk.scala
package com.tristanhunt.knockoff

import scala.collection.mutable.ListBuffer
import scala.util.parsing.input.Position

case class BulletLineChunk( val content : String ) extends Chunk {

  def appendNewBlock( list : ListBuffer[ Block ],
                      remaining : List[ (Chunk, SpanSeq, Position) ],
                      spans : SpanSeq,
                      position : Position )
                    ( elementFactory : ElementFactory, discounter : Discounter )
  : Unit = {
    val li = elementFactory.uli( elementFactory.para(spans, position),
                                 position )
    if ( list.isEmpty ) {
      list += elementFactory.ulist( li )
    } else {
      list.last match {
        case ul : UnorderedList =&gt; val appended = ul + li
                                   list.update( list.length - 1, appended )
        case _ =&gt; list += elementFactory.ulist( li )
      }
    }
  }
}
</code></pre><h2><code>NumberedLineChunk</code></h2><pre><code class="prettyprint">// In com/tristanhunt/knockoff/NumberedLineChunk.scala
package com.tristanhunt.knockoff

import scala.collection.mutable.ListBuffer
import scala.util.parsing.input.Position
    
case class NumberedLineChunk( val content : String ) extends Chunk {

  def appendNewBlock( list : ListBuffer[ Block ],
                      remaining : List[ (Chunk, SpanSeq, Position) ],
                      spans : SpanSeq,
                      position : Position )
                    ( elementFactory : ElementFactory, discounter : Discounter )
  : Unit = {
    val li = elementFactory.oli( elementFactory.para(spans, position),
                                 position )
    if ( list.isEmpty ) {
      list += elementFactory.olist( li )
    } else {
      list.last match {
        case ol : OrderedList =&gt; val appended = ol + li
                                 list.update( list.length - 1, appended )
        case _ =&gt; list += elementFactory.olist( li )
      }
    }
  }
}
</code></pre><h2><code>HeaderChunk</code></h2><pre><code class="prettyprint">// In com/tristanhunt/knockoff/HeaderChunk.scala
package com.tristanhunt.knockoff

import scala.collection.mutable.ListBuffer
import scala.util.parsing.input.Position

case class HeaderChunk( val level : Int, val content : String ) extends Chunk {

  def appendNewBlock( list : ListBuffer[ Block ],
                      remaining : List[ (Chunk, SpanSeq, Position) ],
                      spans : SpanSeq,
                      position : Position )
                    ( elementFactory : ElementFactory, discounter : Discounter )
  : Unit = {
    list += elementFactory.head( level, elementFactory.toSpan(spans), position )
  }
}
</code></pre><h2><code>IndentedChunk</code></h2><pre><code class="prettyprint">// In com/tristanhunt/knockoff/IndentedChunk.scala
package com.tristanhunt.knockoff

import scala.collection.mutable.ListBuffer
import scala.util.parsing.input.Position

/**
  This represents a group of lines that have at least 4 spaces/1 tab preceding
  the line.
*/
case class IndentedChunk( val content : String ) extends Chunk {
  /**
    If the block before is a list, we append this to the end of that list.
    Otherwise, append it as a new code block. Two code blocks will get combined
    here (because it's common to have an empty line not be indented in many
    editors). Appending to the end of a list means that we strip out the first
    indent and reparse things.
  */
  def appendNewBlock( list : ListBuffer[ Block ],
                      remaining : List[ (Chunk, SpanSeq, Position) ],
                      spans : SpanSeq,
                      position : Position )
                    ( elementFactory : ElementFactory, discounter : Discounter )
  : Unit = {
    if ( list.isEmpty ) {
      spans.first match {
        case text : Text =&gt; list += elementFactory.codeBlock( text, position )
      }
    } else {
      list.last match {
        case ml : MarkdownList =&gt;
          val bs = discounter.knockoff( content )
          val updated = ( ml /: bs )( (ml, block) =&gt; ml + block )
          list.update( list.length - 1, updated )

        case cb : CodeBlock =&gt;
          spans.first match {
            case text : Text =&gt;
              list.update( list.length - 1,
                           elementFactory.codeBlock(
                             elementFactory.text(cb.text.content + text.content),
                             cb.position ) )

            case s : Span =&gt;
              error( &quot;Expected Text(code) for code block append, not &quot; + s )
          }

        case _ =&gt;
          spans.first match {
            case text : Text =&gt;
              list += elementFactory.codeBlock( text, position )
            case s : Span =&gt;
              error( &quot;Expected Text(code) for code block addition, not &quot; + s )
          }
      }
    }
  }
}
</code></pre><h2><code>BlockquotedChunk</code></h2><p>Represents a single level of blockquoted material. That means that it could also
contain content, which is then reparsed, recursively.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/BlockquotedChunk.scala
package com.tristanhunt.knockoff

import scala.collection.mutable.ListBuffer
import scala.util.parsing.input.Position

/**
  @param content The material, not parsed, but also not containing this level's
                 '&gt;' characters.
*/
case class BlockquotedChunk( val content : String ) extends Chunk {

  def appendNewBlock( list : ListBuffer[ Block ],
                      remaining : List[ (Chunk, SpanSeq, Position) ],
                      spans : SpanSeq,
                      position : Position )
                    ( elementFactory : ElementFactory, discounter : Discounter )
  : Unit = {
    val blocks = discounter.knockoff( content )
    list += elementFactory.blockquote( blocks, position )
  }
}
</code></pre><h2><code>LinkDefinitionChunk</code></h2><pre><code class="prettyprint">// In com/tristanhunt/knockoff/LinkDefinitionChunk.scala
package com.tristanhunt.knockoff

import scala.collection.mutable.ListBuffer
import scala.util.parsing.input.Position

case class LinkDefinitionChunk( val id : String, val url : String,
                                val title : Option[ String ] )
extends Chunk {

  override def isLinkDefinition = true
  
  def content : String = &quot;[&quot; + id + &quot;]: &quot; + url + (
    title.map( &quot; \&quot;&quot; + _ + &quot;\&quot;&quot; ).getOrElse(&quot;&quot;)
  )
  
  def appendNewBlock( list : ListBuffer[ Block ],
                      remaining : List[ (Chunk, SpanSeq, Position) ],
                      spans : SpanSeq,
                      position : Position )
                    ( elementFactory : ElementFactory, discounter : Discounter )
  : Unit = {
    list += elementFactory.linkdef( id, url, title, position )
  }
}
</code></pre></div>
      <div class="footer span-22 prepend-1 append-1 last">
      
    </div>
    </div></body>
      </html>