<!DOCTYPE html>
<html>
        <head>
          <title>Span Conversion</title>
          <link rel="stylesheet" href="../../screen.css" type="text/css" media="screen, projection"></link><link rel="stylesheet" href="../../print.css" type="text/css" media="print"></link><!--[if lt IE 8]><link rel="stylesheet" href="../../ie.css" type="text/css" media="screen, projection"><![endif]-->
          <link href="../../prettify.css" rel="stylesheet" type="text/css"></link><script type="text/javascript" src="../../prettify.js"></script>
          <style> 
          /* Overriding a few defaults from blueprint. */
          body {font-size:100%;color:#222;background:#f2e5ca;font-family: Georgia, Times, serif;}
          h1, h2, h3, h4, h5, h6 {font-weight:normal;color:#111;font-family: Georgia, Times, serif;text-transform:uppercase;}
          a:focus, a:hover {color: #222;}
          a {color:#7f2f18;text-decoration:none;}
          code { text-transform: none; }
          
          /* Style the code blocks */
          pre {
            background: #333;
            color: #f2e5ca;
            border: solid #444 1px;
            border-left-width: 1em;
          }
          .str { color:rgb( 237, 239, 125 ); font-style:italic }
          .kwd { color:rgb( 152, 129, 85 ); }
          .com { color:#999 }
          .typ { color:rgb( 255, 101, 33 ); }
          .lit { color:rgb( 112, 83, 147 ); }
          .pun { color:#aaa; font-weight:bold  }
          .pln { color:#f2e5ca }
          .tag { color:rgb( 137, 150, 168 ); font-weight:bold  }
          .atn { color:#939; font-weight:bold  }
          .atv { color:#181 }
          .dec { color:#606 }
          
          /* Custom styling */
          .header { background: #7f2f18; color: #f2e5ca; text-transform:uppercase; margin-bottom: 2em; vertical-align: center; }
          .header a { color: #f2e5ca }
          .header a:focus, a:hover {color: #222; background: #7f2f18 }
          .header ul { list-style-type: none; margin: 0; padding: 0; }
          .header ul li { display: inline; padding-right: 2em; }
           </style>
        </head>
        <body onload="prettyPrint()" class="container"><div class="section">
      <div class="header span-22 prepend-1 append-1 last">
      <ul style="list-style-type: none">
            <li><a href="../../../..">tristanhunt.com</a></li>
            <li><a href="http://github.com/tristanjuricek/knockoff">GitHub</a></li>
            <li><a href="../../../literable">Literable</a></li>
        </ul>
    </div>
      <div class="nav small span-7 prepend-1"><ul><li>
            <a href="../../01-Introduction.html">
              Introduction to Knockoff
            </a>
          </li><li>
            <span class="group">Usage</span>
            <ul>
              <li>
            <a href="../../10-Usage/01-Getting_Started.html">
              Getting Started
            </a>
          </li><li>
            <a href="../../10-Usage/02-Recipes.html">
              Recipes
            </a>
          </li>
            </ul>
          </li><li>
            <span class="group">Implementation</span>
            <ul>
              <li>
            <a href="../../30-Implementation/01-Discounter.html">
              Discounter - The One Trait
            </a>
          </li><li>
            <a href="../../30-Implementation/02-Block_Elements.html">
              Block Elements
            </a>
          </li><li>
            <a href="../../30-Implementation/03-Span_Elements.html">
              Spanning Elements
            </a>
          </li><li>
            <a href="../../30-Implementation/04-ElementFactory.html">
              ElementFactory
            </a>
          </li><li>
            <span class="group">Parsing</span>
            <ul>
              <li>
            <a href="../../30-Implementation/10-Parsing/01-Parsing.html">
              Parsing Overview
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/10-ChunkStreamFactory.html">
              ChunkStreamFactory
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/11-ChunkParsers.html">
              ChunkParsers
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/12-Chunk_Types.html">
              Chunk Types
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/20-Span_Conversion.html">
              Span Conversion
            </a>
          </li>
            </ul>
          </li><li>
            <a href="../../30-Implementation/50-Official_Markdown_Tests.html">
              The Official Tests
            </a>
          </li><li>
            <span class="group">Utilities</span>
            <ul>
              <li>
            <a href="../../30-Implementation/80-Utilities/01-String_Extras.html">
              StringExtras
            </a>
          </li><li>
            <a href="../../30-Implementation/80-Utilities/02-ColoredLogger.html">
              ColoredLogger
            </a>
          </li>
            </ul>
          </li>
            </ul>
          </li></ul></div>
      <div class="article span-15 append-1 last"><h1>Span Conversion</h1><p>Our little spanning matching system is broken up into a tail-recursive system that
slowly puts together our strings by:
</p><ol><li>Trying out all alternatives of the next significant spanning element from the
current point.
</li><li>Picking the best match based on earliest first location.
</li><li>Processing current content if it can.
</li><li>Processing the rest of the tail content.
</li></ol><p>This is initiated by the <code>SpanConverterFactory</code>, which sets up a converter, and
creates a bunch of mixins. These mixins are really only intended to
</p><h2><code>SpanConverterFactory</code></h2><p>We configure a conversion method with a list of <code>LinkDefinitionChunks</code>, because we
usually convert a chunk of text at a time, where the definitions are in other
chunks, probably at the end of the document. Otherwise, the conversion method is a
pretty simple mapping function.
</p><p>Conversion itself is a pretty brute-force approach encapsulated in the
<code>SpanConverter</code> class.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/SpanConverterFactory.scala
package com.tristanhunt.knockoff

trait SpanConverterFactory extends HasElementFactory {
 
  def spanConverter( definitions : Seq[ LinkDefinitionChunk ] ) : Chunk =&gt; SpanSeq =
    new SpanConverter( definitions, elementFactory )
}
</code></pre><h2><code>SpanConverter</code></h2><p>The converter implements the tail-recursive methods for spinning through the
content. Note that this recurses in two directions. One, when we find the next
spanning element, this will call itself to work on the tail, iterating &quot;down&quot; the
string. But on certain elements, the element itself contains a Span, so this
converter configures that matcher to kick off another parsing run on the substring
of that span.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/SpanConverter.scala
package com.tristanhunt.knockoff

class SpanConverter(
  val definitions    : Seq[ LinkDefinitionChunk ],
  val elementFactory : ElementFactory
)
extends Function1[ Chunk, SpanSeq ]
with    EqualDelimiterMatcher
with    CodeMatchers
with    EmphasisMatchers
with    StrongMatchers
with    StrongAndEmMatchers
with    HTMLMatchers
with    LinkMatcher
with    StringExtras {
     
  /**
    The SpanConverter is a map method from Chunk to SpanSeq
  */
  def apply( chunk : Chunk ) : SpanSeq = {
    chunk match {
      case IndentedChunk( content ) =&gt; new Text( content )
      case _ =&gt; convert( chunk.content, Nil )
    }
  }
  
  /**
    Tail-recursive method halts when the content argument is empty.
  */
  protected def convert( content : String, current : List[ Span ] ) : Span = {

    if ( content.isEmpty ) return elementFactory.toSpan( current )

    val textOnly =
      SpanMatch( content.length, None, elementFactory.text( content ), None )

    val bestMatch = ( textOnly /: matchers ){ (current, findMatch) =&gt;
      findMatch( content ) match {
        case None =&gt; current
        case Some( nextMatch ) =&gt; {
          if ( nextMatch.index &lt; current.index )
            nextMatch
          else
            current
        }
      }
    }
  
    val updated =
      current ::: bestMatch.before.toList ::: List( bestMatch.current )
  
    bestMatch.after match {
      case None              =&gt; elementFactory.toSpan( updated )
      case Some( remaining ) =&gt; convert( remaining, updated )
    }
  }
  
  def matchers : List[ String =&gt; Option[SpanMatch] ] = List(
    matchDoubleCodes,
    matchSingleCodes,
    matchLink,
    matchHTMLComment,
    matchEntity,
    matchHTMLSpan,
    matchUnderscoreStrongAndEm,
    matchAsterixStrongAndEm,
    matchUnderscoreStrong,
    matchAsterixStrong,
    matchUnderscoreEmphasis,
    matchAsterixEmphasis
  )
}
</code></pre><h2><code>SpanMatch</code></h2><p>The primary result returned by a <code>SpanMatcher</code>. It's <code>index</code> will become an ordering
attribute for determining the &quot;best&quot; match.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/SpanMatch.scala
package com.tristanhunt.knockoff

case class SpanMatch(
  val index   : Int,
  val before  : Option[ Text ],
  val current : Span,
  val after   : Option[ String ]
)
</code></pre><h2><code>Emphasis</code> Matching</h2><p>Emphasis can start with an underscore <code>_</code> or an asterix <code>*</code>, and can have embedded
elements. Examples:
</p><pre><code class="prettyprint">_dude_
*dude*
an _emphasized expression `with code` inside!_
</code></pre><p>Both are configured by the <code>EmphasisMatchers</code>.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/EmphasisMatchers.scala
package com.tristanhunt.knockoff

trait EmphasisMatchers { self : EqualDelimiterMatcher with SpanConverter =&gt;
 
  def matchUnderscoreEmphasis( source : String ) =
    matchEqualDelimiters( source )( &quot;_&quot;, createEmphasisSpanMatch, true, Some('\\') )

  def matchAsterixEmphasis( source : String ) =
    matchEqualDelimiters( source )( &quot;*&quot;, createEmphasisSpanMatch, true, Some('\\') )

  def createEmphasisSpanMatch(
    i : Int, b : Option[Text], span : Span, a : Option[ String ]
  ) = {
    SpanMatch( i, b, elementFactory.em( span ), a )
  }
}
</code></pre><h3><code>EmphasisMatchersSpec</code></h3><pre><code class="prettyprint">// The EmphasisMatchers specification
describe( &quot;EmphasisMatchers&quot; ) {
  it(&quot;should match underscores containing asterix emphases&quot;) {
    val converted = spanConverter( Nil )(
      TextChunk( &quot;a _underscore *and block* em_&quot; )
    )
    converted.toList should equal { List(
      text(&quot;a &quot;),
      em( toSpan( List( t(&quot;underscore &quot;), em( t(&quot;and block&quot;) ), t(&quot; em&quot;) ) ) )
    ) }
  }
}
</code></pre><h2><code>Strong</code> (Like Bull) Matching</h2><p>Like <code>Emphasis</code> elements, <code>Strong</code> elements use two underscores <code>__</code> or asterixes
<code>**</code> to figure themselves out.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/StrongMatchers.scala
package com.tristanhunt.knockoff

trait StrongMatchers { self : EqualDelimiterMatcher with SpanConverter =&gt;
  
  def matchUnderscoreStrong( source : String ) =
    matchEqualDelimiters( source )( &quot;__&quot;, createStrongSpanMatch, true, Some('\\') )
  
  def matchAsterixStrong( source : String ) =
    matchEqualDelimiters( source )( &quot;**&quot;, createStrongSpanMatch, true, Some('\\') )
  
  def createStrongSpanMatch(
    i : Int, b : Option[Text], span : Span, a : Option[ String ]
  ) = {
    SpanMatch( i, b, elementFactory.strong( span ), a )
  }
}
</code></pre><h3><code>StrongMatchersSpec</code></h3><pre><code class="prettyprint">// The StrongMatchers specification
describe( &quot;StrongMatchers&quot; ) {
  it(&quot;should match underscores containing asterix emphases&quot;) {
    val converted = spanConverter( Nil )(
      TextChunk( &quot;an __underscore **and asterix** strong__&quot; )
    )
    converted.toList should equal { List(
      text(&quot;an &quot;),
      strong(
        toSpan(
          List( t(&quot;underscore &quot;), strong( t(&quot;and asterix&quot;) ), t(&quot; strong&quot;) )
        )
      )
    ) }
  }
}
</code></pre><h2>Strong and <code>em</code> at the same time</h2><pre><code class="prettyprint">// In com/tristanhunt/knockoff/StrongAndEmMatchers.scala
package com.tristanhunt.knockoff

trait StrongAndEmMatchers { self : EqualDelimiterMatcher with SpanConverter =&gt;
  
    def matchUnderscoreStrongAndEm( source : String ) = {
      matchEqualDelimiters( source )( &quot;___&quot;, createStrongAndEm, true, Some('\\') )
    }
  
    def matchAsterixStrongAndEm( source : String ) = {
      matchEqualDelimiters( source )( &quot;***&quot;, createStrongAndEm, true, Some('\\') )
    }
  
    def createStrongAndEm(
      i : Int, b : Option[Text], span : Span, a : Option[ String ]
    ) = {
      import elementFactory.{ strong, em }
      SpanMatch( i, b, strong( Seq( em( span ) ) ), a )
    }
}
</code></pre><h2><code>Code</code> Matching</h2><p>Two varations of code blocks:
</p><pre><code class="prettyprint">A `normal code` block
A ``code with a `backtick` inside``
</code></pre><p>This is all done by balanced code matching via the <code>EqualDelimiterMatcher</code>.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/CodeMatchers.scala
package com.tristanhunt.knockoff

trait CodeMatchers { self : EqualDelimiterMatcher with SpanConverter =&gt;
 
  def matchDoubleCodes( source : String ) : Option[ SpanMatch ] =
    matchEqualDelimiters( source )( &quot;``&quot;, createCodeSpanMatch, false, None )

  def matchSingleCodes( source : String ) : Option[ SpanMatch ] =
    matchEqualDelimiters( source )( &quot;`&quot;, createCodeSpanMatch, false, None )
  
  def createCodeSpanMatch(
    i : Int, b : Option[Text], span : Span, a : Option[ String ]
  ) = {
    val codeSpan = span match {
      case text : Text =&gt; elementFactory.codeSpan( text.content )
    }
    SpanMatch( i, b, codeSpan, a )
  }
}
</code></pre><h4><code>CodeMatcherSpec</code></h4><pre><code class="prettyprint">// The CodeMatchers specification
describe( &quot;CodeMatchers&quot; ) {

  it( &quot;should parse a couple of single code blocks in text&quot; ) {
    val spans = spanConverter( Nil )(
      TextChunk(&quot;a `code1` and a `code 2`&quot;)
    )
    val expected = List(
      t(&quot;a &quot;), codeSpan(&quot;code1&quot;), t(&quot; and a &quot;), codeSpan(&quot;code 2&quot;)
    )
    assert( spans sameElements expected )
  }

  it(&quot;should not care about other elements in the code&quot;) {
    val converted = spanConverter( Nil )(
      TextChunk(&quot;This `code block *with em*` is OK&quot;)
    )
    converted.toList should equal { List(
      text(&quot;This &quot;),
      codeSpan( &quot;code block *with em*&quot; ),
      text(&quot; is OK&quot;)
    ) }
  }
  
  it(&quot;double-tick code markers should preserve whitespace&quot;) {
    val converted = spanConverter(Nil)( TextChunk(&quot;AA `` ` `` BB&quot;) )
    converted.toList should equal { List(
      text(&quot;AA &quot;),
      codeSpan(&quot; ` &quot;),
      text(&quot; BB&quot;)
    ) }
  }
}
</code></pre><h2>HTML Matching</h2><p>If we find any kind of HTML/XML-like element within the content, and it's not a
single element, we try to find the ending element. If that segment isn't
well-formed, we just ignore the element, and treat it like text.
</p><h3><code>HTMLMatchers</code></h3><p>Any sequences of HTML in content are matched by the <code>InlineHTMLMatcher</code>. Note that
this uses a recursive method <code>hasMatchedClose</code> to deal with the situations where
one span contains other spans - it's basically like parenthesis matching.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/HTMLSpanMatcher.scala
package com.tristanhunt.knockoff

trait HTMLMatchers { self : SpanConverter =&gt;
  
  private val startElement = &quot;&quot;&quot;&lt;[ ]*([a-zA-Z0-9:_]+)[ \t]*[^&gt;]*?(/?+)&gt;&quot;&quot;&quot;.r
  
  def matchHTMLSpan( source : String ) : Option[ SpanMatch ] = {
    startElement.findFirstMatchIn( source ).map { open =&gt;
      val hasEnd = open.group(2) == &quot;/&quot;
      val noEnd = SpanMatch(
        open.start,
        open.before.toOption.map( elementFactory.text(_) ),
        elementFactory.htmlSpan( open.matched ),
        open.after.toOption
      )
      if ( ! hasEnd ) {
        hasMatchedClose( source, open.group(1), open.end, 1 ) match {
          case Some((close, after)) =&gt; SpanMatch(
            open.start,
            open.before.toOption.map( elementFactory.text(_) ),
            elementFactory.htmlSpan(
              source.substring( open.start, close )
            ),
            after.toOption
          )
          // Let no html-like thing go unpunished.
          case None =&gt; noEnd
        }
      } else {
        noEnd
      }
    }
  }
  
  private def hasMatchedClose(
    source : String,
    tag    : String,
    from   : Int,
    opens  : Int
  ) : Option[ ( Int, CharSequence ) ] = {
    val opener = (&quot;(?i)&lt;[ ]*&quot; + tag + &quot;[ \t]*[^&gt;]*?(/?+)*&gt;&quot;).r
    val closer = (&quot;(?i)&lt;/[ ]*&quot; + tag + &quot;[ ]*&gt;&quot;).r
    
    val nextOpen  = opener.findFirstMatchIn( source.substring(from) )
    val nextClose = closer.findFirstMatchIn( source.substring(from) )

    if ( ! nextClose.isDefined ) return None
    
    if ( nextOpen.isDefined &amp;&amp; ( nextOpen.get.start &lt; nextClose.get.start ) ) {
        hasMatchedClose( source, tag, from + nextOpen.get.end, opens + 1 )
    } else if ( opens &gt; 1 ) {
        hasMatchedClose( source, tag, from + nextClose.get.end, opens - 1 )
    } else {
        Some( ( from + nextClose.get.end, nextClose.get.after ) )
    }
  }
  
  private val matchEntityRE = &quot;&quot;&quot;&amp;\w+;&quot;&quot;&quot;.r

  def matchEntity( source : String ) : Option[ SpanMatch ] = {
    matchEntityRE.findFirstMatchIn( source ).map{ entityMatch =&gt;
      SpanMatch(
        entityMatch.start,
        entityMatch.before.toOption.map( elementFactory.text(_) ),
        elementFactory.htmlSpan( entityMatch.matched ),
        entityMatch.after.toOption
      )
    }
  }

  def matchHTMLComment( source : String ) :Option[ SpanMatch ] = {
    val open = source.indexOf(&quot;&lt;!--&quot;)
    if ( open &gt; -1 ) {
      val close = source.indexOf( &quot;--&gt;&quot;, open )
      if ( close &gt; -1 ) {
        return Some( SpanMatch(
          open,
          source.substring( 0, open ).toOption.map( elementFactory.text(_) ),
          elementFactory.htmlSpan( source.substring( open, close + &quot;--&gt;&quot;.length ) ),
          source.substring( close + &quot;--&gt;&quot;.length ).toOption
        ) )
      }
    }
    return None
  }
}
</code></pre><h4><code>HTMLSpanMatcherSpec</code></h4><pre><code class="prettyprint">// The HTMLSpanMatcher specification
describe(&quot;HTMLSpanMatcher&quot;) {
  it(&quot;should find an &lt;a&gt; and an &lt;img&gt;&quot;) {
    val spans = spanConverter( Nil )( TextChunk(
      &quot;&quot;&quot;with &lt;a href=&quot;http://example.com&quot;&gt;a link&lt;/a&gt; and an &quot;&quot;&quot; +
      &quot;&quot;&quot;&lt;img src=&quot;foo.img&quot;/&gt; ha!&quot;&quot;&quot;
    ) )
    spans.toList should equal ( List(
      t(&quot;with &quot;),
      htmlSpan(&quot;&quot;&quot;&lt;a href=&quot;http://example.com&quot;&gt;a link&lt;/a&gt;&quot;&quot;&quot;),
      t(&quot; and an &quot;),
      htmlSpan(&quot;&quot;&quot;&lt;img src=&quot;foo.img&quot;/&gt;&quot;&quot;&quot;),
      t(&quot; ha!&quot;)
    ) )
  }
  
  it(&quot;should wrap a &lt;span&gt; that contains another &lt;span&gt;&quot;) {
    val convertedSpans = spanConverter( Nil ){ TextChunk(
      &quot;&quot;&quot;a &lt;span class=&quot;container&quot;&gt;contains &lt;span&gt;something&lt;/span&gt;&quot;&quot;&quot; +
      &quot;&quot;&quot; else&lt;/span&gt; without a problem &lt;br /&gt; !&quot;&quot;&quot;
    ) }
    convertedSpans.toList should equal { List(
      t(&quot;a &quot;),
      htmlSpan(
        &quot;&quot;&quot;&lt;span class=&quot;container&quot;&gt;contains &quot;&quot;&quot; +
        &quot;&quot;&quot;&lt;span&gt;something&lt;/span&gt; else&lt;/span&gt;&quot;&quot;&quot;
      ),
      t(&quot; without a problem &quot;),
      htmlSpan(&quot;&lt;br /&gt;&quot;),
      t(&quot; !&quot;)
    ) }
  }
  
  it(&quot;should find a couple of entities and pass them through&quot;) {
    val converted = spanConverter( Nil )(
        TextChunk( &quot;an &amp;amp; and an &amp;em; are in here&quot; )
    )
    converted.toList should equal( List(
      t(&quot;an &quot;),
      htmlSpan(&quot;&amp;amp;&quot;),
      t(&quot; and an &quot;),
      htmlSpan(&quot;&amp;em;&quot;),
      t(&quot; are in here&quot;)
    ) )
  }
  
  it(&quot;should handle HTML headers defined in text&quot;) {
    val converted = spanConverter(Nil)(
        TextChunk(&quot;&lt;h2 id=\&quot;overview\&quot;&gt;Overview&lt;/h2&gt;&quot;)
    )
    converted.toList should equal( List(
      htmlSpan(&quot;&lt;h2 id=\&quot;overview\&quot;&gt;Overview&lt;/h2&gt;&quot;)
    ) )
  }
}
</code></pre><h2>Link Matching</h2><p>Recall that links come in 4 major varieties, and here is where we figure out what
they are:
</p><ol><li>Inline urls: <code>[wrapped](url &quot;title&quot;)</code>
</li><li>Inline images: <code>![alt](url &quot;title&quot;)</code>
</li><li>Reference: <code>[wrapped][id]</code>
</li><li>Automatic: <code>&lt;url&gt;</code>
</li></ol><p>A major caveat is that we need to be able to handle parens within the wrapped text.
So, things like:
</p><pre><code class="prettyprint">I'm [a link](http://example.com &quot;Title (in paren)&quot;)
</code></pre><h3><code>LinkMatcher</code></h3><pre><code class="prettyprint">// In com/tristanhunt/knockoff/LinkMatcher.scala
package com.tristanhunt.knockoff

import scala.util.matching.Regex.Match

trait LinkMatcher { self : SpanConverter =&gt;
  
  def matchLink( source : String ) : Option[ SpanMatch ] = {
    normalLinks.findFirstMatchIn( source ) match {
      case None =&gt;
        findAutomaticMatch( source ).orElse( findReferenceMatch( source ) )
      case Some( matchr ) =&gt;
        findNormalMatch( source, matchr )
    }
  }
  
  private val automaticLinkRE = &quot;&quot;&quot;&lt;((http:|mailto:|https:)\S+)&gt;&quot;&quot;&quot;.r
  
  def findAutomaticMatch( source : String ) : Option[ SpanMatch ] = {
    automaticLinkRE.findFirstMatchIn( source ).map { aMatch =&gt;
      val url = aMatch.group(1)
      SpanMatch(
        aMatch.start,
        aMatch.before.toOption.map( elementFactory.text(_) ),
        elementFactory.link( elementFactory.text( url ), url, None ),
        aMatch.after.toOption
      )
    }
  }
  
  def findNormalMatch( source : String, matchr : Match )
  : Option[ SpanMatch ] = {
    val isImage     = matchr.group(1) == &quot;!&quot; || matchr.group(4) == &quot;!&quot;
    val hasTitle    = matchr.group(7) != null
    val wrapped     = if( hasTitle ) matchr.group(5) else matchr.group(2)
    val url         = if( hasTitle ) matchr.group(6) else matchr.group(3)
    val titleOption = if ( hasTitle ) Some( matchr.group(7) ) else None
    Some(
      SpanMatch(
        matchr.start,
        matchr.before.toOption.map( elementFactory.text(_) ),
        if ( isImage )
          elementFactory.ilink( convert( wrapped, Nil ), url, titleOption )
        else
          elementFactory.link( convert( wrapped, Nil ), url, titleOption ),
        matchr.after.toOption
      )
    )
  }
  
  /**
    This regular expression will try to match links like: [wrap](url) and
    [wrap](url &quot;title&quot;), in image mode or not.
    
    Groups:
    &lt;ul&gt;
    &lt;li&gt; 1 - &quot;!&quot; for image, no title &lt;/li&gt;
    &lt;li&gt; 2 - wrapped content, no title &lt;/li&gt;
    &lt;li&gt; 3 - url, no title &lt;/li&gt;
    &lt;li&gt; 4 - &quot;!&quot; for image, with title &lt;/li&gt;
    &lt;li&gt; 5 - wrapped content, with title &lt;/li&gt;
    &lt;li&gt; 6 - url, with title &lt;/li&gt;
    &lt;li&gt; 7 - title &lt;/li&gt;
    &lt;/ul&gt;
  */
  val normalLinks = (
    &quot;&quot;&quot;(!?)\[([^\]]*)\][\t ]*\(&lt;?([\S&amp;&amp;[^)&gt;]]*)&gt;?\)|&quot;&quot;&quot; +
    &quot;&quot;&quot;(!?)\[([^\]]*)\][\t ]*\(&lt;?([\S&amp;&amp;[^)&gt;]]*)&gt;?[\t ]+&quot;([^)]*)&quot;\)&quot;&quot;&quot;
  ).r
  
  /**
    We have to match parens, to support this stuff: [wr [app] ed] [thing]
  */
  def findReferenceMatch( source : String ) : Option[ SpanMatch ] = {
    val firstOpen = source.indexOf('[')
    if ( firstOpen == -1 ) return None
    
    val firstClose =
      source.findBalanced('[', ']', firstOpen).getOrElse( return None )

    val secondPart = source.substring( firstClose + 1 )

    val secondMatch =
      &quot;&quot;&quot;^\s*(\[)&quot;&quot;&quot;.r.findFirstMatchIn( secondPart ).getOrElse( return None )

    val secondClose =
      secondPart.findBalanced( '[', ']', secondMatch.start(1) ).get
    if ( secondClose == -1 ) return None

    val refID = {
      val no2 = secondPart.substring( secondMatch.start(1) + 1, secondClose )
      if ( no2.isEmpty ) source.substring( firstOpen + 1, firstClose ) else no2
    }
    val precedingText = source.substring( 0, firstOpen ).toOption.map(
      elementFactory.text(_)
    )
    
    definitions.find( _.id equalsIgnoreCase refID ).map {
      definition : LinkDefinitionChunk =&gt;
        SpanMatch(
          firstOpen,
          precedingText,
          elementFactory.link(
            elementFactory.text( source.substring( firstOpen + 1, firstClose ) ),
            definition.url,
            definition.title
          ),
          source.substring( firstClose + secondClose + 2 ).toOption
        )
    }
  }
}
</code></pre><h3><code>LinkMatcherSpec</code></h3><pre><code class="prettyprint">// The LinkMatcher specification
describe(&quot;LinkMatcher&quot;) {
  it(&quot;should discover inline, image, automatic, and reference links&quot;) {
    val convert = spanConverter(
      Seq( new LinkDefinitionChunk(&quot;link1&quot;, &quot;http://example.com&quot;, Some(&quot;title&quot;) ) )
    )
    val converted = convert(
      TextChunk(
        &quot;A [link](http://example.com/link1) &quot; +
        &quot;An ![image link](http://example.com/image1 \&quot;image test\&quot;) &quot; +
        &quot;The &lt;http://example.com/automatic&gt; &quot; +
        &quot;A [reference link] [link1]&quot;
      )
    )
    converted.toList should equal { List(
      text(&quot;A &quot;),
      link( t(&quot;link&quot;), &quot;http://example.com/link1&quot; ),
      text(&quot; An &quot;),
      ilink( t(&quot;image link&quot;), &quot;http://example.com/image1&quot;, Some(&quot;image test&quot;) ),
      text(&quot; The &quot;),
      link( t(&quot;http://example.com/automatic&quot;), &quot;http://example.com/automatic&quot; ),
      text(&quot; A &quot;),
      link( t(&quot;reference link&quot;), &quot;http://example.com&quot;, Some(&quot;title&quot;) )
    ) }
  }
  
  it(&quot;should hande link references in different case&quot;) {
    val convert = spanConverter( Seq(
      new LinkDefinitionChunk(&quot;link 1&quot;, &quot;http://example.com/1&quot;, None),
      new LinkDefinitionChunk(&quot;link 2&quot;, &quot;http://example.com/2&quot;, None)
    ) )
    val converted = convert( TextChunk(&quot;[Link 1][] and [link 2][]&quot;) )
    converted.toList should equal { List(
      link( t(&quot;Link 1&quot;), &quot;http://example.com/1&quot; ),
      text(&quot; and &quot;),
      link( t(&quot;link 2&quot;), &quot;http://example.com/2&quot; )
    ) }
  }
}
</code></pre><h2><code>EqualDelimiterMatcher</code></h2><p>Many of the elements are delimited by the identical character sequence on either
side of the text. This does the dirty work of finding those matches, whatever that
character sequence may be.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/EqualDelimiterMatcher.scala
package com.tristanhunt.knockoff

trait EqualDelimiterMatcher { self : SpanConverter with StringExtras =&gt;
  
  /**
    @param delim The delimiter string to match the next 2 sequences of.
    @param toSpanMatch Factory to create the actual SpanMatch.
    @param recursive If you want the contained element to be reconverted.
  */
  def matchEqualDelimiters( source : String )(
    delim       : String,
    toSpanMatch : ( Int, Option[ Text ], Span, Option[ String ] ) =&gt; SpanMatch,
    recursive   : Boolean,
    escape      : Option[ Char ]
  ) : Option[ SpanMatch ] = {
    source.nextNIndicesOf( 2, delim, escape ) match {
      case List( start, end ) =&gt; {
        if ( start + delim.length &gt;= end ) return None
        val contained = source.substring( start + delim.length, end )
        val content = {
          if ( recursive ) convert( contained, Nil )
          else elementFactory.text( contained )
        }
        Some(
          toSpanMatch(
            start,
            source.substringOption( 0, start ).map( elementFactory.text ),
            content,
            source.substringOption( end + delim.length, source.length )
          )
        )
      }
      case _ =&gt; None
    }
  }
}
</code></pre><h2>Escaping</h2><p>The following characters should be escapable, which means that by putting a
backslash <code>\</code> in front of the character, you should not see it in output:
</p><pre><code class="prettyprint">\   backslash
`   backtick
*   asterisk
_   underscore
{}  curly braces
[]  square brackets
()  parentheses
#   hash mark
+   plus sign
-   minus sign (hyphen)
.   dot
!   exclamation mark
</code></pre><p>This means that a normal backslash by itself should not be seen unless it's inside
a code block.
</p><pre><code class="prettyprint">// The Escaping specification
describe(&quot;Escaping system&quot;) {

  it(&quot;should escape asterixes in content&quot;) {
    val converted = spanConverter(Nil)(
      TextChunk(&quot;&quot;&quot;an \*escaped\* emphasis&quot;&quot;&quot;)
    )
    converted.toList should equal( List(
      text(&quot;&quot;&quot;an \*escaped\* emphasis&quot;&quot;&quot;)
    ) )
  }
  
  it(&quot;should escape backticks in content&quot;) {
    val converted = spanConverter(Nil)(
      TextChunk(&quot;&quot;&quot;an escaped \' backtick&quot;&quot;&quot;)
    )
    converted.toList should equal( List(
      text(&quot;&quot;&quot;an escaped \' backtick&quot;&quot;&quot;)
    ) )
  }
  
  it(&quot;should ignore backslashes in code&quot;) {
    val converted = spanConverter(Nil)(
      TextChunk(&quot;&quot;&quot;a backslash `\` in code&quot;&quot;&quot;)
    )
    converted.toList should equal( List(
      text(&quot;&quot;&quot;a backslash &quot;&quot;&quot;),
      codeSpan(&quot;\\&quot;),
      text(&quot;&quot;&quot; in code&quot;&quot;&quot;)
    ) )
  }
}
</code></pre><h2>Testing Specification via <code>SpanConverterSpec</code></h2><pre><code class="prettyprint">// In test com/tristanhunt/knockoff/SpanConverterSpec.scala
package com.tristanhunt.knockoff

import org.scalatest._
import org.scalatest.matchers._
import scala.util.parsing.input.NoPosition

class   SpanConverterSpec
extends Spec
with    ShouldMatchers
with    SpanConverterFactory
with    ColoredLogger {
  
  val factory = elementFactory
  import factory._
  
  override def spanConverter( definitions : Seq[ LinkDefinitionChunk ] ) : Chunk =&gt; SpanSeq =
    new SpanConverter( definitions, elementFactory ) with ColoredLogger

  // See the CodeMatchers specification
  
  // See the EmphasisMatchers specification

  // See the StrongMatchers specification
  
  // See the HTMLSpanMatcher specification
  
  // See the LinkMatcher specification
  
  // See the Escaping specification
}
</code></pre></div>
      <div class="footer span-22 prepend-1 append-1 last">
      
    </div>
    </div></body>
      </html>