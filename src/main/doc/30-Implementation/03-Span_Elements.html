<!DOCTYPE html>
<html>
        <head>
          <title>Spanning Elements</title>
          <link rel="stylesheet" href="../screen.css" type="text/css" media="screen, projection"></link><link rel="stylesheet" href="../print.css" type="text/css" media="print"></link><!--[if lt IE 8]><link rel="stylesheet" href="../ie.css" type="text/css" media="screen, projection"><![endif]-->
          <link href="../prettify.css" rel="stylesheet" type="text/css"></link><script type="text/javascript" src="../prettify.js"></script>
          <style> 
          /* Overriding a few defaults from blueprint. */
          body {font-size:100%;color:#222;background:#f2e5ca;font-family: Georgia, Times, serif;}
          h1, h2, h3, h4, h5, h6 {font-weight:normal;color:#111;font-family: Georgia, Times, serif;text-transform:uppercase;}
          a:focus, a:hover {color: #222;}
          a {color:#7f2f18;text-decoration:none;}
          code { text-transform: none; }
          
          /* Style the code blocks */
          pre {
            background: #333;
            color: #f2e5ca;
            border: solid #444 1px;
            border-left-width: 1em;
          }
          .str { color:rgb( 237, 239, 125 ); font-style:italic }
          .kwd { color:rgb( 152, 129, 85 ); }
          .com { color:#999 }
          .typ { color:rgb( 255, 101, 33 ); }
          .lit { color:rgb( 112, 83, 147 ); }
          .pun { color:#aaa; font-weight:bold  }
          .pln { color:#f2e5ca }
          .tag { color:rgb( 137, 150, 168 ); font-weight:bold  }
          .atn { color:#939; font-weight:bold  }
          .atv { color:#181 }
          .dec { color:#606 }
          
          /* Custom styling */
          .header { background: #7f2f18; color: #f2e5ca; text-transform:uppercase; margin-bottom: 2em; vertical-align: center; }
          .header a { color: #f2e5ca }
          .header a:focus, a:hover {color: #222; background: #7f2f18 }
          .header ul { list-style-type: none; margin: 0; padding: 0; }
          .header ul li { display: inline; padding-right: 2em; }
           </style>
        </head>
        <body onload="prettyPrint()" class="container"><div class="section">
      <div class="header span-22 prepend-1 append-1 last">
      <ul style="list-style-type: none">
            <li><a href="../../..">tristanhunt.com</a></li>
            <li><a href="http://github.com/tristanjuricek/knockoff">GitHub</a></li>
            <li><a href="../../literable">Literable</a></li>
        </ul>
    </div>
      <div class="nav small span-7 prepend-1"><ul><li>
            <a href="../01-Introduction.html">
              Introduction to Knockoff
            </a>
          </li><li>
            <span class="group">Usage</span>
            <ul>
              <li>
            <a href="../10-Usage/01-Getting_Started.html">
              Getting Started
            </a>
          </li><li>
            <a href="../10-Usage/02-Recipes.html">
              Recipes
            </a>
          </li>
            </ul>
          </li><li>
            <span class="group">Implementation</span>
            <ul>
              <li>
            <a href="../30-Implementation/01-Discounter.html">
              Discounter - The One Trait
            </a>
          </li><li>
            <a href="../30-Implementation/02-Block_Elements.html">
              Block Elements
            </a>
          </li><li>
            <a href="../30-Implementation/03-Span_Elements.html">
              Spanning Elements
            </a>
          </li><li>
            <a href="../30-Implementation/04-ElementFactory.html">
              ElementFactory
            </a>
          </li><li>
            <span class="group">Parsing</span>
            <ul>
              <li>
            <a href="../30-Implementation/10-Parsing/01-Parsing.html">
              Parsing Overview
            </a>
          </li><li>
            <a href="../30-Implementation/10-Parsing/10-ChunkStreamFactory.html">
              ChunkStreamFactory
            </a>
          </li><li>
            <a href="../30-Implementation/10-Parsing/11-ChunkParsers.html">
              ChunkParsers
            </a>
          </li><li>
            <a href="../30-Implementation/10-Parsing/12-Chunk_Types.html">
              Chunk Types
            </a>
          </li><li>
            <a href="../30-Implementation/10-Parsing/20-Span_Conversion.html">
              Span Conversion
            </a>
          </li>
            </ul>
          </li><li>
            <a href="../30-Implementation/50-Official_Markdown_Tests.html">
              The Official Tests
            </a>
          </li><li>
            <span class="group">Utilities</span>
            <ul>
              <li>
            <a href="../30-Implementation/80-Utilities/01-String_Extras.html">
              StringExtras
            </a>
          </li><li>
            <a href="../30-Implementation/80-Utilities/02-ColoredLogger.html">
              ColoredLogger
            </a>
          </li>
            </ul>
          </li>
            </ul>
          </li></ul></div>
      <div class="article span-15 append-1 last"><h1>Spanning Elements</h1><h2><code>Span</code></h2><p>Marks a string to become the basic building block of the Markdown tree.
</p><p>Each Span is also a sequence of other Spans - some elements, like a link definition,
can have part of it's description be code.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/Span.scala
package com.tristanhunt.knockoff

import scala.xml.Node

trait Span extends SpanSeq {
  def markdown : String
  def xml : Node
}

object Span {
  val empty : Span = new Text(&quot;&quot;)
}
</code></pre><h2><code>SpanSeq</code></h2><p>Each <code>Block</code> is composed of these.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/SpanSeq.scala
package com.tristanhunt.knockoff

import scala.xml.Group

trait SpanSeq extends Seq[ Span ] {
  def theSeq : Seq[ Span ]
  override def length : Int = theSeq.length
  override def elements = theSeq.elements
  override def apply( ii : Int ) = theSeq(ii)
  
  def toXML = Group( theSeq.flatMap( _.xml ) )
  
  def toMarkdown = theSeq.map( _.markdown ).mkString(&quot;&quot;)
}
</code></pre><p>A simpler version is for the common case, where the span does not actually contain
other spans.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/SimpleSpan.scala
package com.tristanhunt.knockoff

trait SimpleSpan extends Span {
  def theSeq = List( this )
}
</code></pre><p>The other, complex case is where a span contains a straight list of children.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/ComplexSpan.scala
package com.tristanhunt.knockoff

trait ComplexSpan extends Span {
  val children : Seq[ Span ]
  def theSeq = children
  def childrenMarkdown = children.map( _.markdown ).mkString(&quot;&quot;)
  def childrenXML = toXML
}
</code></pre><p>And a workaround to cases where we need just a container of spans.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/GroupSpan.scala
package com.tristanhunt.knockoff

import scala.xml.Group

class GroupSpan( val children : SpanSeq ) extends ComplexSpan {
 
  def this( seq : Seq[ Span ] ) {
    this( new SpanSeq { def theSeq = seq } )
  }
  
  def xml = toXML
  
  def markdown = toMarkdown
}
</code></pre><h2><code>Text</code></h2><p>The most basic Span element that contains no other markup information.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/Text.scala
package com.tristanhunt.knockoff

import scala.xml.{ Node, Text =&gt; XMLText }

class Text( val content : String ) extends SimpleSpan {

  def markdown = content

  def xml : Node =
    XMLText( unescape( content ) )
  
  val escapeableChars = List(
      &quot;\\&quot;, &quot;`&quot;, &quot;*&quot;, &quot;_&quot;, &quot;{&quot;, &quot;}&quot;, &quot;[&quot;, &quot;]&quot;, &quot;(&quot;, &quot;)&quot;, &quot;#&quot;, &quot;+&quot;, &quot;-&quot;, &quot;.&quot;, &quot;!&quot;, &quot;&gt;&quot;
  )

  def unescape(source:String):String = {
      var buf:String = source
      for ((escaped, unescaped) &lt;- escapeableChars.map(ch =&gt; (&quot;\\&quot; + ch, ch)))
          buf = buf.replace(escaped, unescaped)
      buf
  }

  // See the Text toString, hashCode, equals implementations
}
</code></pre><h2><code>HTMLSpan</code></h2><p>These sequences are found inside of blocks, but still mean &quot;just pass it on&quot;.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/HTMLSpan.scala
package com.tristanhunt.knockoff

import scala.xml.{ Node, Unparsed }

class HTMLSpan( val content : String ) extends SimpleSpan {

  def markdown = content

  def xml : Node = Unparsed( content )

  // See the HTMLSpan toString, hashCode, equals implementations       
}
</code></pre><h2><code>CodeSpan</code></h2><p>These are usually represented by inline <code>&lt;code&gt;</code> blocks in paragraph text. This is
not to be confused with <code>CodeBlock</code> - a <code>CodeBlock</code> does not contain a <code>CodeSpan</code>.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/CodeSpan.scala
package com.tristanhunt.knockoff

import scala.xml.Node

class CodeSpan( val content : String ) extends SimpleSpan {

  def markdown = content

  def xml : Node = &lt;code&gt;{ content }&lt;/code&gt;

  // See the CodeSpan toString, hashCode, equals implementations       
}
</code></pre><h2><code>Strong</code></h2><p>These emphasize other spans, usually with <code>&lt;strong&gt;</code> tags.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/Strong.scala
package com.tristanhunt.knockoff

import scala.xml.Node

class Strong( val children : Seq[ Span ] ) extends ComplexSpan {
  
  def markdown = &quot;**&quot; + childrenMarkdown + &quot;**&quot;
  
  def xml : Node = &lt;strong&gt;{ childrenXML }&lt;/strong&gt;
  
  // See the Strong toString, hashCode, equals implementations
}
</code></pre><h2><code>Emphasis</code></h2><p>Wraps other spans with <code>&lt;em&gt;</code> tags.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/Emphasis.scala
package com.tristanhunt.knockoff

import scala.xml.Node

class Emphasis( val children : Seq[ Span ] ) extends ComplexSpan {

  def markdown = &quot;_&quot; + childrenMarkdown + &quot;_&quot;

  def xml : Node = &lt;em&gt;{ childrenXML }&lt;/em&gt;

  // See the Emphasis toString, hashCode, equals implementations
}
</code></pre><h2>Links</h2><p>Links are kind of special spanning elements, because there are
</p><ol><li>Direct links, e.g., <code>[title](url)</code>
</li><li>Indirect links, e.g., <code>[title][reference]</code>
</li><li>Image links, e.g., <code>![title](url)</code>
</li></ol><h3><code>Link</code></h3><p>The direct link is is simply called a <code>Link</code>.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/Link.scala
package com.tristanhunt.knockoff

import scala.util.Random
import scala.xml._

class Link(
  val children  : SpanSeq,
  val url       : String,
  val title     : Option[ String ]
)
extends ComplexSpan {
    
  def markdown = {
    &quot;[&quot; + childrenMarkdown + &quot;](&quot; +
    url + {
      title match {
        case Some( titleString ) =&gt; &quot; \&quot;&quot; + titleString + &quot;\&quot;&quot;
        case None =&gt; &quot;&quot;
      }
    } + &quot;)&quot;
  }
  
  def xml : Node =
    &lt;a href={ escapedOrPlainURL } title={ title.getOrElse(null) }&gt;{ childrenXML }&lt;/a&gt;
  
  def escapedOrPlainURL =
    if ( url startsWith &quot;mailto:&quot; ) Unparsed( escapedURL ) else Text( url )
  
  def escapedURL = {
    val rand = new Random
    url.map { ch =&gt;
      rand.nextInt(2) match {
        case 0 =&gt; java.lang.String.format( &quot;&amp;#%d;&quot;, int2Integer( ch.toInt ) )
        case 1 =&gt; java.lang.String.format( &quot;&amp;#x%s;&quot;, ch.toInt.toHexString )
      }
    }.mkString(&quot;&quot;)
  }
  
  // See the Link toString, hashCode, equals implementations
}
</code></pre><h4><code>LinkSpec</code></h4><pre><code class="prettyprint">// In test com/tristanhunt/knockoff/LinkSpec.scala
package com.tristanhunt.knockoff

import org.scalatest._
import org.scalatest.matchers._

class LinkSpec extends Spec with ShouldMatchers {
  
  val factory = new ElementFactory
  import factory._
 
  describe(&quot;Link&quot;) {
    it(&quot;should entitize html mailto: links&quot;) {
      val jdoe = link( text(&quot;jdoe&quot;), &quot;mailto:jdoe@example.com&quot; )
      ( jdoe.xml \ &quot;@href&quot; ) should not equal {
        &quot;mailto:jdoe@example.com&quot;
      }
    }
  }
}
</code></pre><h3><code>IndirectLink</code></h3><p>Indirect links are tied to <code>LinkDefinition</code> elements, which are a special <code>Block</code>
type. (The link definitions can't be found in the middle of a paragraph.)
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/IndirectLink.scala
package com.tristanhunt.knockoff

class IndirectLink(
  children        : SpanSeq,
  val definition  : LinkDefinition
)
extends Link( children, definition.url, definition.title )
with    ComplexSpan {
    
  override def markdown = &quot;[&quot; + childrenMarkdown + &quot;][&quot; + definition.id + &quot;]&quot;
    
  // See the IndirectLink toString, hashCode, equals implementations        
}
</code></pre><h3><code>ImageLink</code> and <code>IndirectImageLink</code></h3><p>Image links are standard link references prefixed with an exclamation mark <code>!</code>. The
image aspect is done via this trait:
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/ImageSpan.scala
package com.tristanhunt.knockoff

import scala.xml.Node

trait ImageSpan extends Link {
  override def markdown = &quot;!&quot; + super.markdown
  
  override def xml : Node = &lt;img
    src={ url }
    title={ title.getOrElse(null) }
    alt={ childrenXML.text }
  &gt;&lt;/img&gt;
}
</code></pre><p>We then the actual classes using a mixin.
</p><h4><code>ImageLink</code></h4><pre><code class="prettyprint">// In com/tristanhunt/knockoff/ImageLink.scala
package com.tristanhunt.knockoff

import scala.xml.Node

class ImageLink(
  children  : SpanSeq,
  url       : String,
  title     : Option[ String ]
)
extends Link( children, url, title )
with    ImageSpan {
  // See the ImageLink toString, hashCode, equals implementations
}
</code></pre><h4><code>IndirectImageLink</code></h4><pre><code class="prettyprint">// In com/tristanhunt/knockoff/IndirectImageLink.scala
package com.tristanhunt.knockoff

import scala.xml.Node

class IndirectImageLink(
  children    : SpanSeq,
  definition  : LinkDefinition
)
extends IndirectLink( children, definition )
with    ImageSpan {
  // See the IndirectImageLink toString, hashCode, equals implementations
}
</code></pre><h2>Why No Case Classes?</h2><p>Each of these classes are <strong>not</strong> case classes, as I expect that people may want to
override them, to alter HTML output, for example. The <a href="04-ElementFactory.html" >`ElementFactory`</a> can
then be overridden to generate the right output.
</p><p>This has resulted in a wee bit of duplication (boo), now made referencable at in
this location... (yay?)
</p><h4><code>Text.hashCode/equals</code></h4><pre><code class="prettyprint">// The Text toString, hashCode, equals implementations
override def toString = &quot;Text(&quot; + content + &quot;)&quot;

override def hashCode : Int = content.hashCode
    
override def equals( rhs : Any ) : Boolean = rhs match {
  case t : Text =&gt; t.canEqual( this ) &amp;&amp; ( t.content == content )
  case _ =&gt; false
}
    
def canEqual( t : Text ) : Boolean = t.getClass == getClass
</code></pre><h4><code>HTMLSpan.hashCode/equals</code></h4><pre><code class="prettyprint">// The HTMLSpan toString, hashCode, equals implementations
override def toString = &quot;HTMLSpan(&quot; + content + &quot;)&quot;

override def hashCode : Int = content.hashCode
    
override def equals( rhs : Any ) : Boolean = rhs match {
  case t : HTMLSpan =&gt; t.canEqual( this ) &amp;&amp; ( t.content == content )
  case _ =&gt; false
}
    
def canEqual( t : HTMLSpan ) : Boolean = t.getClass == getClass
</code></pre><h4><code>CodeSpan.hashCode/equals</code></h4><pre><code class="prettyprint">// The CodeSpan toString, hashCode, equals implementations
override def toString = &quot;CodeSpan(&quot; + content + &quot;)&quot;

override def hashCode : Int = content.hashCode
    
override def equals( rhs : Any ) : Boolean = rhs match {
  case t : CodeSpan =&gt; t.canEqual( this ) &amp;&amp; ( t.content == content )
  case _ =&gt; false
}
    
def canEqual( t : CodeSpan ) : Boolean = t.getClass == getClass
</code></pre><h4><code>Strong.hashCode/equals</code></h4><pre><code class="prettyprint">// The Strong toString, hashCode, equals implementations
override def toString = &quot;Strong(&quot; + markdown + &quot;)&quot;

override def hashCode : Int =
  41 + ( (3 /: children)( (sum, child) =&gt; 41 + sum + 3 * child.hashCode ) )

override def equals( rhs : Any ) : Boolean = rhs match {
  case t : Strong =&gt; t.canEqual( this ) &amp;&amp; ( t.children sameElements children )
  case _ =&gt; false
}

def canEqual( s : Strong ) : Boolean = s.getClass == getClass
</code></pre><h4><code>Emphasis.hashCode/equals</code></h4><pre><code class="prettyprint">// The Emphasis toString, hashCode, equals implementations
override def toString = &quot;Emphasis(&quot; + markdown + &quot;)&quot;

override def hashCode : Int =
  43 + ( (3 /: children)( (sum, child) =&gt; 43 + sum + 3 * child.hashCode ) )

override def equals( rhs : Any ) : Boolean = rhs match {
  case t : Emphasis =&gt; t.canEqual( this ) &amp;&amp; ( t.children sameElements children )
  case _ =&gt; false
}

def canEqual( s : Emphasis ) : Boolean = s.getClass == getClass
</code></pre><h4><code>Link.hashCode/equals</code></h4><pre><code class="prettyprint">// The Link toString, hashCode, equals implementations
override def toString = &quot;Link(&quot; + markdown + &quot;)&quot;

override def hashCode : Int = {
  ( 43 + ( (3 /: children)( (sum, child) =&gt; 43 + sum + 3 * child.hashCode ) ) ) +
  ( 43 + url.hashCode ) +
  ( 43 + title.hashCode )
}

override def equals( rhs : Any ) : Boolean = rhs match {
  case t : Link =&gt; ( t.canEqual( this ) ) &amp;&amp; ( this sameElements t )
  case _ =&gt; false
}

def canEqual( s : Link ) : Boolean = s.getClass == getClass

def sameElements( l : Link ) : Boolean = {
  ( l.children sameElements children ) &amp;&amp;
  ( url == l.url ) &amp;&amp;
  ( title == l.title )
}
</code></pre><h4><code>IndirectLink.hashCode/equals</code></h4><pre><code class="prettyprint">// The IndirectLink toString, hashCode, equals implementations
override def toString = &quot;IndirectLink(&quot; + markdown + &quot;)&quot;

override def hashCode : Int =
  41 + ( (7 /: children)( (sum, child) =&gt; 41 + sum + 7 * child.hashCode ) )

override def equals( rhs : Any ) : Boolean = rhs match {
  case t : IndirectLink =&gt; ( t.canEqual( this ) ) &amp;&amp; ( this sameElements t )
  case _ =&gt; false
}

def canEqual( s : IndirectLink ) : Boolean = s.getClass == getClass
</code></pre><h4><code>ImageLink toString/hashCode/equals</code></h4><pre><code class="prettyprint">// The ImageLink toString, hashCode, equals implementations
override def toString = &quot;ImageLink(&quot; + markdown + &quot;)&quot;

override def hashCode : Int =
  37 + ( (13 /: children)( (sum, child) =&gt; 37 + sum + 13 * child.hashCode ) )

override def equals( rhs : Any ) : Boolean = rhs match {
  case t : ImageLink =&gt; t.canEqual( this ) &amp;&amp; ( this sameElements t )
  case _ =&gt; false
}

def canEqual( s : ImageLink ) : Boolean = s.getClass == getClass
</code></pre><h4><code>IndirectImageLink.hashCode/equals</code></h4><pre><code class="prettyprint">// The IndirectImageLink toString, hashCode, equals implementations
override def toString = &quot;IndirectImageLink(&quot; + markdown + &quot;)&quot;

override def hashCode : Int = {
  41 + ( (11 /: children){
    (sum, child) =&gt; 41 + sum + 11 * child.hashCode
  } )
}

override def equals( rhs : Any ) : Boolean = rhs match {
  case t : IndirectImageLink =&gt;
    ( t.canEqual( this ) ) &amp;&amp; ( this sameElements t )
  case _ =&gt; false
}

def canEqual( s : IndirectImageLink ) : Boolean = s.getClass == getClass
</code></pre></div>
      <div class="footer span-22 prepend-1 append-1 last">
      
    </div>
    </div></body>
      </html>