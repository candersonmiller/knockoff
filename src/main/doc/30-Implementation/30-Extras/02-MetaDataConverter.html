<!DOCTYPE html>
<html>
        <head>
          <title>MetaData and MetaDataConverter</title>
          <link rel="stylesheet" href="../../screen.css" type="text/css" media="screen, projection"></link><link rel="stylesheet" href="../../print.css" type="text/css" media="print"></link><!--[if lt IE 8]><link rel="stylesheet" href="../../ie.css" type="text/css" media="screen, projection"><![endif]-->
          <link href="../../prettify.css" rel="stylesheet" type="text/css"></link><script type="text/javascript" src="../../prettify.js"></script>
          <style> 
          /* Overriding a few defaults from blueprint. */
          body {font-size:100%;color:#222;background:#f2e5ca;font-family: Georgia, Times, serif;}
          h1, h2, h3, h4, h5, h6 {font-weight:normal;color:#111;font-family: Georgia, Times, serif;text-transform:uppercase;}
          a:focus, a:hover {color: #222;}
          a {color:#7f2f18;text-decoration:none;}
          code { text-transform: none; }
          
          /* Style the code blocks */
          pre {
            background: #333;
            color: #f2e5ca;
            border: solid #444 1px;
            border-left-width: 1em;
          }
          .str { color:rgb( 237, 239, 125 ); font-style:italic }
          .kwd { color:rgb( 152, 129, 85 ); }
          .com { color:#999 }
          .typ { color:rgb( 255, 101, 33 ); }
          .lit { color:rgb( 112, 83, 147 ); }
          .pun { color:#aaa; font-weight:bold  }
          .pln { color:#f2e5ca }
          .tag { color:rgb( 137, 150, 168 ); font-weight:bold  }
          .atn { color:#939; font-weight:bold  }
          .atv { color:#181 }
          .dec { color:#606 }
          
          /* Custom styling */
          .header { background: #7f2f18; color: #f2e5ca; text-transform:uppercase; margin-bottom: 2em; vertical-align: center; }
          .header a { color: #f2e5ca }
          .header a:focus, a:hover {color: #222; background: #7f2f18 }
          .header ul { list-style-type: none; margin: 0; padding: 0; }
          .header ul li { display: inline; padding-right: 2em; }
           </style>
        </head>
        <body onload="prettyPrint()" class="container"><div class="section">
      <div class="header span-22 prepend-1 append-1 last">
      <ul style="list-style-type: none">
            <li><a href="../../../..">tristanhunt.com</a></li>
            <li><a href="http://github.com/tristanjuricek/knockoff">GitHub</a></li>
            <li><a href="../../../literable">Literable</a></li>
        </ul>
    </div>
      <div class="nav small span-7 prepend-1"><ul><li>
            <a href="../../01-Introduction.html">
              Introduction to Knockoff
            </a>
          </li><li>
            <span class="group">Usage</span>
            <ul>
              <li>
            <a href="../../10-Usage/01-Getting_Started.html">
              Getting Started
            </a>
          </li><li>
            <a href="../../10-Usage/02-Recipes.html">
              Recipes
            </a>
          </li><li>
            <a href="../../10-Usage/50-Variations.html">
              Where Knockoff is not like Markdown
            </a>
          </li>
            </ul>
          </li><li>
            <span class="group">Implementation</span>
            <ul>
              <li>
            <a href="../../30-Implementation/01-Discounter_DefaultDiscounter_Wholesaler.html">
              Discounter and the Wholesaler
            </a>
          </li><li>
            <a href="../../30-Implementation/02-Block_Elements.html">
              Block Elements
            </a>
          </li><li>
            <a href="../../30-Implementation/03-Span_Elements.html">
              Spanning Elements
            </a>
          </li><li>
            <a href="../../30-Implementation/04-ElementFactory.html">
              ElementFactory
            </a>
          </li><li>
            <span class="group">Parsing</span>
            <ul>
              <li>
            <a href="../../30-Implementation/10-Parsing/01-Parsing.html">
              Parsing Overview
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/10-ChunkStreamFactory.html">
              ChunkStreamFactory
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/11-ChunkParsers.html">
              ChunkParsers
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/12-Chunk_Types.html">
              Chunk Types
            </a>
          </li><li>
            <a href="../../30-Implementation/10-Parsing/20-Span_Conversion.html">
              Span Conversion
            </a>
          </li>
            </ul>
          </li><li>
            <span class="group">Extras</span>
            <ul>
              <li>
            <a href="../../30-Implementation/30-Extras/02-MetaDataConverter.html">
              MetaData and MetaDataConverter
            </a>
          </li>
            </ul>
          </li><li>
            <a href="../../30-Implementation/50-Official_Markdown_Tests.html">
              The Official Tests
            </a>
          </li><li>
            <span class="group">Utilities</span>
            <ul>
              <li>
            <a href="../../30-Implementation/80-Utilities/01-String_Extras.html">
              StringExtras
            </a>
          </li><li>
            <a href="../../30-Implementation/80-Utilities/02-ColoredLogger.html">
              ColoredLogger
            </a>
          </li>
            </ul>
          </li>
            </ul>
          </li></ul></div>
      <div class="article span-15 append-1 last"><h1><code>MetaData</code> and <code>MetaDataConverter</code></h1><p>Methods to convert <code>Paragraph</code> to <code>MetaData</code>. A <code>Paragraph</code> is <code>MetaData</code> if all
lines can be converted to key/value strings.
</p><p>A key value string is a line that has two text sections divided by a colon.
</p><pre><code class="prettyprint">key : value
</code></pre><p>Spaces around the key will be trimmed.
</p><p>A key value can have a trailing line appended to the value, only if the previous
line ends with two spaces and then a newline.
</p><h2><code>MetaData</code></h2><p><code>MetaData</code> is really just a <code>Map</code> of strings. But, we want to return it in the
<code>BlockSeq</code>, so it's a special kind of <code>Block</code>.
</p><p>The values of the map shoudn't contain the separating newline.
</p><p>There is no XML representation of <code>MetaData</code>. Conversion to header elements is
left to your program to interpret.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/extra/MetaData.scala
package com.tristanhunt.knockoff.extra
// See the MetaData imports

class   MetaData( val data : Map[ String, String ], val position : Position )
extends SimpleBlock {
  
  val span : SpanSeq = new Text( markdown )
  
  /** This should be an empty element. */
  val xml : Node = new Group( new NodeBuffer )
  
  val markdown : String =
    data.map{ case ((k,v)) =&gt; k + &quot;: &quot; + v }.mkString(&quot;\n&quot;)
}
// The MetaData imports

import scala.util.parsing.input.Position
import scala.xml.{ Group, Node, NodeBuffer }
</code></pre><h2><code>MetaDataConverter</code></h2><pre><code class="prettyprint">// In com/tristanhunt/knockoff/extra/MetaDataConverter.scala
package com.tristanhunt.knockoff.extra
// See the MetaDataConverter imports

trait MetaDataConverter {
  
  /**
    @param  para The paragraph to be converted. We use the trimmed markdown 
                 value to determine the data.
    @return Some metadata equivalent of the paragraph. Or, None.
   */
  def toMetaData( para : Paragraph ) : Option[ MetaData ] =
    parseLine( para.markdown.trim.split(&quot;\n&quot;), new ListBuffer )
      .map( new MetaData( _, para.position ) )
  
  /**
    Creates the string map that becomes the main data for MetaData.
  
    @param in  Each line of markdown content, minus the trailing newlines.
    @param out The current &quot;chunks&quot; of metadata. Each chunk can contain multiple
               lines.
    @return The parsed Metadata when every line can be chunked, or None.
    */
  private def parseLine( in : Seq[ String ], out : ListBuffer[ String ] )
                        : Option[ Map[ String, String ] ] = {
    if ( in.isEmpty ) return Some( toMetaDataMap( out ) )
    in.first.indexOf(':') match {
      case -1 =&gt;
        if ( out.isEmpty || ! out.last.endsWith(&quot;  &quot;) ) return None
        else {
          val newChunk = out.last + &quot;\n&quot; + in.first
          out.trimEnd(1)
          out += newChunk
        }
      case idx =&gt; out += in.first
    }
    parseLine( in.drop(1), out )
  }

  private def toMetaDataMap( out : Seq[ String ] ) : Map[ String, String ] =
    Map( out.map { chunk =&gt;
          val idx = chunk.indexOf(':')
          ( chunk.substring(0, idx).trim, chunk.substring(idx + 1) )
         } : _* )
}

// The MetaDataConverter imports

import scala.collection.mutable.ListBuffer
</code></pre><h2><code>MetaDataConverterSpec</code></h2><pre><code class="prettyprint">// In test com/tristanhunt/knockoff/extra/MetaDataConverterSpec.scala
package com.tristanhunt.knockoff.extra
// See the MetaDataConverterSpec imports

class MetaDataConverterSpec extends Spec with ShouldMatchers with Wholesaler {

  describe(&quot;MetaDataConverter&quot;) {
    it(&quot;should convert a Paragraph to MetaData&quot;) {
      val content = &quot;key 1 : value\n&quot; +
                    &quot;key2:value\n&quot; +
                    &quot;key 3 : long  \n&quot; +
                    &quot;        value\n&quot; +
                    &quot;key4:\n&quot; +
                    &quot;:oops&quot;

      val metaData =
        toMetaData( new Paragraph( new Text( content ), NoPosition ) )
        .getOrElse( error(&quot;Did not convert the content to MetaData&quot;) )
      
      metaData.data should equal (
        Map( &quot;key 1&quot; -&gt; &quot; value&quot;,
             &quot;key2&quot;  -&gt; &quot;value&quot;,
             &quot;key 3&quot; -&gt; &quot; long  \n        value&quot;,
             &quot;key4&quot;  -&gt; &quot;&quot;,
             &quot;&quot;      -&gt; &quot;oops&quot; )
      )
    }
  }
}

// The MetaDataConverterSpec imports

import org.scalatest.Spec
import org.scalatest.matchers.ShouldMatchers
import scala.util.parsing.input.NoPosition
</code></pre><h2><code>MetaDatas</code></h2><p>This enables the <code>filterType</code> method to work to find the <code>MetaData</code>.
</p><pre><code class="prettyprint">// In com/tristanhunt/knockoff/extra/MetaDatas.scala
package com.tristanhunt.knockoff.extra

case object MetaDatas
extends BlockType[ MetaData ] { def wrappedClass = classOf[ MetaData ] }
</code></pre></div>
      <div class="footer span-22 prepend-1 append-1 last">
      
    </div>
    </div></body>
      </html>